Generating consolidated code output...

--- FILE_START ---
PATH: package.json
TYPE: json
CONTENT:
```
{
  "name": "phulkas-earning-v2",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "postinstall": "prisma generate",
    "db:seed": "ts-node --project tsconfig.ts-node.json prisma/seed.ts",
    "test": "jest"
  },
  "dependencies": {
    "@auth/prisma-adapter": "^2.9.1",
    "@date-io/date-fns": "^3.2.1",
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/icons-material": "^7.1.0",
    "@mui/lab": "^7.0.0-beta.12",
    "@mui/material": "^7.1.0",
    "@mui/x-date-pickers": "^8.3.1",
    "@mui/x-date-pickers-pro": "^8.3.1",
    "date-fns": "^4.1.0",
    "next": "15.3.2",
    "next-auth": "^4.24.7",
    "next-intl": "^4.1.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "recharts": "^2.15.3",
    "sqlite3": "^5.1.7"
  },
  "devDependencies": {
    "@babel/core": "^7.27.1",
    "@babel/preset-env": "^7.27.2",
    "@types/jest": "^29.5.14",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "babel-jest": "^29.7.0",
    "esbuild": "^0.25.4",
    "jest": "^29.7.0",
    "prisma": "^6.8.2",
    "ts-jest": "^29.3.4",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: next.config.ts
TYPE: typescript
CONTENT:
```
import {NextConfig} from 'next';
import createNextIntlPlugin from 'next-intl/plugin';

const nextConfig: NextConfig = {};
const withNextIntl = createNextIntlPlugin();
export default withNextIntl(nextConfig);
```
--- FILE_END ---

--- FILE_START ---
PATH: prisma/schema.prisma
TYPE: prisma
CONTENT:
```
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  // Provider is "sqlite"
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Define an Enum for meal types
enum MealType {
  LUNCH
  DINNER
}

model Bill {
  id          Int       @id @default(autoincrement())
  date        DateTime
  foodAmount  Float
  drinkAmount Float
  mealType    MealType @default(LUNCH)
  isOurFood   Boolean?  @default(true)
  numberOfPeopleWorkingDinner Int? @default(1)
  comments    String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([date]) // Add an index on the date field for faster querying
}

// Add other models if you have them (e.g., User model for authentication)
// Assuming these are needed for NextAuth.js with Prisma adapter
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  // Removed @db.Text as it's not supported by SQLite
  id_token          String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}


model PurchaseBill {
  id          Int      @id @default(autoincrement())
  date        DateTime  // Date of the purchase
  amount      Float    // Total cost of the purchase
  description String   // e.g., "Vegetables from market", "Meat supplier", "Grocery store"
  comments    String?  // Optional detailed comments about the purchase
}

```
--- FILE_END ---

--- FILE_START ---
PATH: prisma/seed.ts
TYPE: typescript
CONTENT:
```
// prisma/seed.ts
import { PrismaClient, MealType } from '@prisma/client';
import { addDays, subMonths, getDay } from 'date-fns';

const prisma = new PrismaClient();

// Lunch Price Points
const lunchBasePrices = [1300, 1400];
const lunchAddonPrices = [250, 300];

// Drink Price
const drinkPrice = 450;

// Dinner Food Price Points
const dinnerFoodPrices = [250, 300, 400];

async function main() {
  console.log('Seeding the database with realistic pricing...');

  const today = new Date();
  const startDate = subMonths(today, 1);

  const billsData = [];

  for (let i = 0; i < 30; i++) {
    const currentDate = addDays(startDate, i);
    const dayOfWeek = getDay(currentDate);

    // --- Lunch Entries (Wed/Thu focus) ---
    if (dayOfWeek === 3 || dayOfWeek === 4) {
      const numLunchBills = Math.floor(Math.random() * 2) + 1; // 1 or 2 lunch bills
      for (let j = 0; j < numLunchBills; j++) {
        let foodAmount = lunchBasePrices[Math.floor(Math.random() * lunchBasePrices.length)];
        const numAddons = Math.floor(Math.random() * 3); // 0 to 2 addons
        for (let k = 0; k < numAddons; k++) {
          foodAmount += lunchAddonPrices[Math.floor(Math.random() * lunchAddonPrices.length)];
        }
        const numDrinks = Math.floor(Math.random() * 3); // 0 to 2 drinks
        const drinkAmount = numDrinks * drinkPrice;

        billsData.push({
          date: currentDate,
          mealType: MealType.LUNCH,
          foodAmount: foodAmount,
          drinkAmount: drinkAmount,
          isOurFood: true,
          numberOfPeopleWorkingDinner: 1,
          comments: 'Wednesday/Thursday Lunch',
        });
      }
    } else if (Math.random() < 0.05) { // Small chance of lunch on other days
      let foodAmount = lunchBasePrices[Math.floor(Math.random() * lunchBasePrices.length)];
      const numAddons = Math.floor(Math.random() * 2);
      for (let k = 0; k < numAddons; k++) {
        foodAmount += lunchAddonPrices[Math.floor(Math.random() * lunchAddonPrices.length)];
      }
      const drinkAmount = Math.floor(Math.random() * 2) * drinkPrice;

      billsData.push({
        date: currentDate,
        mealType: MealType.LUNCH,
        foodAmount: foodAmount,
        drinkAmount: drinkAmount,
        isOurFood: Math.random() < 0.7,
        numberOfPeopleWorkingDinner: 1,
        comments: 'Occasional Lunch',
      });
    }

    // --- Dinner Entries ---
    const numDinnerBills = Math.floor(Math.random() * 3) + 1; // 1 to 3 dinner bills
    for (let j = 0; j < numDinnerBills; j++) {
      let foodAmount = 0;
      const numFoodItems = Math.floor(Math.random() * 3) + 1; // 1 to 3 food items
      for (let k = 0; k < numFoodItems; k++) {
        foodAmount += dinnerFoodPrices[Math.floor(Math.random() * dinnerFoodPrices.length)];
      }
      const numDrinks = Math.floor(Math.random() * 4); // 0 to 3 drinks
      const drinkAmount = numDrinks * drinkPrice;
      const isOurFoodDinner = (dayOfWeek === 3 || dayOfWeek === 4) ? Math.random() < 0.7 : Math.random() < 0.3;
      const numberOfPeopleWorkingDinner = Math.floor(Math.random() * 3) + 1;

      billsData.push({
        date: currentDate,
        mealType: MealType.DINNER,
        foodAmount: foodAmount,
        drinkAmount: drinkAmount,
        isOurFood: isOurFoodDinner,
        numberOfPeopleWorkingDinner: numberOfPeopleWorkingDinner,
        comments: `Dinner service (Our Food: ${isOurFoodDinner ? 'Yes' : 'No'})`,
      });
    }
  }

  await prisma.bill.createMany({
    data: billsData,
  });

  console.log('Realistic pricing database seeding completed.');
}

main()
  .catch((e) => {
    console.error('Error seeding the database:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```
--- FILE_END ---

--- FILE_START ---
PATH: prisma/seed_config.ts
TYPE: typescript
CONTENT:
```
// prisma/seed_config.ts
import { PrismaClient } from '@prisma/client';
import { AppConfig as DefaultAppConfig } from '../src/config/app'; // Import your default AppConfig

const prisma = new PrismaClient();

async function main() {
  console.log('Seeding initial AppConfiguration...');

  // Define the default configuration values based on your AppConfig
  const configToSeed = [
    { key: 'LUNCH_FOOD_BASE_INCOME', value: DefaultAppConfig.LUNCH_FOOD_BASE_INCOME, description: 'Base income for lunch food before overage calculation.' },
    { key: 'LUNCH_FOOD_OVERAGE_SHARE_PERCENT', value: DefaultAppConfig.LUNCH_FOOD_OVERAGE_SHARE_PERCENT, description: 'Percentage of lunch food overage that contributes to earnings.' },
    { key: 'LUNCH_DRINK_SHARE_PERCENT', value: DefaultAppConfig.LUNCH_DRINK_SHARE_PERCENT, description: 'Percentage of lunch drink amount that contributes to earnings.' },
    { key: 'DINNER_FOOD_OUR_SHARE_PERCENT', value: DefaultAppConfig.DINNER_FOOD_OUR_SHARE_PERCENT, description: 'Percentage of dinner food earnings when it is "our food".' },
    { key: 'DINNER_FOOD_COMMON_POOL_PERCENT', value: DefaultAppConfig.DINNER_FOOD_COMMON_POOL_PERCENT, description: 'Percentage of dinner food that goes to the common pool.' },
    { key: 'DINNER_DRINK_COMMON_POOL_PERCENT', value: DefaultAppConfig.DINNER_DRINK_COMMON_POOL_PERCENT, description: 'Percentage of dinner drink that goes to the common pool.' },
  ];

  for (const configItem of configToSeed) {
    await prisma.appConfiguration.upsert({
      where: { key: configItem.key },
      update: { value: configItem.value, description: configItem.description },
      create: { key: configItem.key, value: configItem.value, description: configItem.description },
    });
  }

  console.log('AppConfiguration seeding completed.');
}

main()
  .catch((e) => {
    console.error('Error seeding AppConfiguration:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

```
--- FILE_END ---

--- FILE_START ---
PATH: src/createEmotionCache.ts
TYPE: typescript
CONTENT:
```
// src/createEmotionCache.ts
import createCache from '@emotion/cache';

// Create a shared Emotion cache instance for Material UI SSR
const createEmotionCache = () => {
  return createCache({ key: 'css', prepend: true });
};

export default createEmotionCache;
```
--- FILE_END ---

--- FILE_START ---
PATH: src/theme.ts
TYPE: typescript
CONTENT:
```
// src/theme.ts
import { createTheme } from '@mui/material/styles';
import { Inter } from 'next/font/google';

const inter = Inter({
  weight: ['300', '400', '500', '700'],
  subsets: ['latin'],
  display: 'swap',
});

// Define your light and dark palettes
const lightPalette = {
  primary: {
    main: '#1976d2', // Blue
    light: '#42a5f5',
    dark: '#1565c0',
    contrastText: '#fff', // White text on primary blue
  },
  secondary: {
    main: '#dc004e', // Pink
    light: '#ff3378',
    dark: '#9a0036',
    contrastText: '#fff',
  },
  background: {
    default: '#f4f6f8', // Light grey background
    paper: '#ffffff', // White paper background
  },
  text: {
    primary: '#212121', // Dark text
    secondary: '#757575', // Grey text
  },
  divider: '#e0e0e0',
  mode: 'light' as const, // Explicitly define mode
};

const darkPalette = {
  primary: {
    main: '#90caf9', // Light blue for primary in dark mode (e.g., AppBar, chart bars)
    light: '#e3f2fd',
    dark: '#42a5f5',
    contrastText: '#000', // Black text on light primary for better contrast
  },
  secondary: {
    main: '#f48fb1', // Light pink
    light: '#ffc1e3',
    dark: '#ad1457',
    contrastText: '#000',
  },
  background: {
    default: '#121212', // Dark background
    paper: '#1e1e1e', // Darker paper background
  },
  text: {
    primary: '#ffffff', // White text for primary readability
    secondary: '#e0e0e0', // Very light grey for secondary text
  },
  divider: '#333333',
  mode: 'dark' as const, // Explicitly define mode
};

// Create the light theme
export const lightTheme = createTheme({
  palette: lightPalette,
  typography: {
    fontFamily: inter.style.fontFamily,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 8,
          },
        },
      },
    },
    MuiSelect: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          borderRadius: 0,
        },
      },
    },
  },
});

// Create the dark theme
export const darkTheme = createTheme({
  palette: darkPalette,
  typography: {
    fontFamily: inter.style.fontFamily,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-root': {
            borderRadius: 8,
          },
        },
      },
    },
    MuiSelect: {
      styleOverrides: {
        root: {
          borderRadius: 8,
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          borderRadius: 0,
        },
      },
    },
  },
});

```
--- FILE_END ---

--- FILE_START ---
PATH: src/messages/ja.json
TYPE: json
CONTENT:
```
{
  "login": {
    "title": "Phulkasアプリにログイン",
    "username_label": "ユーザー名",
    "password_label": "パスワード",
    "login_button": "サインイン",
    "login_error": "ログインに失敗しました。認証情報を確認してください。"
  },
  "auth": {
    "unauthenticated": "このページを表示するにはログインしてください",
    "login_failed": "ログインに失敗しました。認証情報を確認してください。"
  },
  "layout": {
    "app_title": "収益アプリ",
    "dashboard_link": "ダッシュボード",
    "summary_link": "概要",
    "purchases_link": "仕入れ",
    "sign_out_button": "サインアウト"
  },
  "language_switcher": {
    "label": "言語",
    "en": "英語",
    "ja": "日本語"
  },
  "summary": {
    "title": "収益概要",
    "summary_title": "収益概要と分析",
    "from_date": "開始日",
    "to_date": "終了日",
    "apply_filter": "フィルターを適用",
    "total_earnings": "総収益",
    "daily_earnings_chart": "毎日の収益",
    "meal_type_distribution_chart": "食事タイプの分布",
    "earnings": "収益",
    "daily_summary_for": "{date}の毎日の概要",
    "total_daily_earnings": "毎日の総収益：¥{amount}",
    "no_bills_found": "選択した日付範囲の請求書が見つかりません。",
    "lunch_summary_title": "昼食の概要",
    "dinner_summary_title": "夕食の概要",
    "food_total": "食事代合計",
    "drink_total": "飲み物代合計",
    "total_earnings_label": "総収益",
    "is_our_food_label": "お店の食事？",
    "num_people_working_label": "人数（夕食）",
    "no_lunch_entries": "昼食のエントリはありません",
    "no_dinner_entries": "夕食のエントリはありません",
    "all_bills_in_range": "範囲内のすべての請求書"
  },
  "date_range_filter": {
    "from_date": "開始日",
    "to_date": "終了日",
    "apply_filter": "フィルターを適用",
    "invalid_date_range": "無効な日付範囲。有効な日付を選択してください。",
    "from_date_after_to_date": "開始日は終了日より前にする必要があります。",
    "dates_not_selected": "開始日と終了日の両方を選択してください。",
    "invalid_date_format": "無効な日付形式。YYYY-MM-DDを使用してください。"
  },
  "dashboard": {
    "title": "ダッシュボード",
    "todays_entries": "今日の登録",
    "summary_for_date": "{date}の概要",
    "lunch_summary": "昼食の概要",
    "dinner_summary": "夕食の概要",
    "day_total_earnings_header": "1日の総収益",
    "food_bills_total": "食品代合計：{amount}",
    "drink_bills_total": "飲み物代合計：{amount}",
    "phulkas_lunch_earnings": "昼食の収益：{amount}",
    "phulkas_dinner_earnings": "夕食の収益：{amount}",
    "add_bill_entry": "新しい請求書エントリを追加",
    "no_entries_today": "今日のエントリはありません。",
    "no_summary_data": "この期間の概要データはありません。",
    "no_bills": "まだ請求書が記録されていません。最初の請求書を追加してください！",
    "edit_bill_title": "請求書を編集",
    "add_bill_title": "新しい請求書を追加",
    "date_label": "日付",
    "meal_type_label": "食事の種類",
    "food_amount_label": "食事代",
    "drink_amount_label": "飲み物代",
    "is_our_food_label": "お店の食事？",
    "num_people_working_label": "夕食の人数",
    "greeting": "こんにちは！",
    "welcome_message": "収益ダッシュボードへようこそ。"
  },
  "meal_type": {
    "lunch": "昼食",
    "dinner": "夕食"
  },
  "earnings_details": {
    "lunch_food_base_income": "昼食の食事代基本収入：{base}",
    "lunch_food_overage": " （+超過分：{overage} / 2 = {overageHalf}）",
    "total_lunch_food_income_share": "昼食の食事代収入分担合計：{amount}",
    "drink_calc_lunch": "飲み物代分担（昼食）：{total} * {percentage}% = {share}",
    "dinner_food_direct_share": "夕食の食事代直接分担（お店の食事の場合）：{share} (生の{total}から)",
    "dinner_common_pool_contrib_food": "食事代共通プール貢献：{amount}",
    "dinner_common_pool_contrib_drinks": "飲み物代共通プール貢献：{amount}",
    "total_common_pool": "共通プール合計：{amount}",
    "our_common_pool_share": "共通プール分担：{amount} ({workers} 人)"
  },
  "bill_list": {
    "date": "日付",
    "meal_type": "食事の種類",
    "food_amount": "食事代",
    "drink_amount": "飲み物代",
    "is_our_food": "お店の食事？",
    "num_people_working": "人数",
    "actions": "操作",
    "edit": "編集",
    "delete": "削除",
    "comments": "コメント"
  },
  "edit": {
    "delete_confirm_title": "削除の確認",
    "delete_confirm_message": "請求書ID {id} を削除してもよろしいですか？",
    "cancel": "キャンセル",
    "delete": "削除",
    "deleting": "請求書を削除しています...",
    "delete_bill_error": "請求書の削除に失敗しました：{error}"
  },
  "errors": {
    "failed_fetch": "データの取得に失敗しました。もう一度お試しください。",
    "bill_not_found": "請求書が見つかりません。",
    "required": "このフィールドは必須です",
    "invalid_date": "無効な日付形式",
    "positive_number": "正の数である必要があります",
    "invalid_date_range": "無効な日付範囲が選択されました。",
    "date_range_order": "開始日は終了日より前にする必要があります。",
    "bill_not_found_for_date": "この日付の請求書が見つかりません。",
    "form_validation_failed": "フォームのエラーを修正してください。",
    "no_purchase_bills_found": "選択した日付範囲の仕入れ請求書は見つかりません。"
  },
  "bill_form": {
    "add_title": "新しい請求書を追加",
    "edit_title": "請求書を編集",
    "date_label": "日付",
    "meal_type_label": "食事の種類",
    "lunch_option": "昼食",
    "dinner_option": "夕食",
    "food_amount_label": "食事代",
    "drink_amount_label": "飲み物代",
    "is_our_food_label": "お店の食事ですか？",
    "num_people_working_label": "夕食の人数",
    "save_button": "請求書を保存",
    "cancel_button": "キャンセル",
    "add_success": "請求書が正常に追加されました！",
    "edit_success": "請求書が正常に更新されました！",
    "add_error": "請求書の追加に失敗しました：{error}",
    "edit_error": "請求書の更新に失敗しました：{error}",
    "num_people_min": "夕食の人数は1以上である必要があります。",
    "comments_label": "コメント"
  },
  "general": {
    "currency": "¥",
    "yes": "はい",
    "no": "いいえ",
    "close": "閉じる",
    "save": "保存",
    "cancel": "キャンセル",
    "delete": "削除",
    "edit_button": "編集",
    "from_date": "開始日",
    "to_date": "終了日",
    "bills": "請求書"
  },
  "purchase_bill_form": {
    "add_title": "新しい仕入れ請求書を追加",
    "edit_title": "仕入れ請求書を編集",
    "date_label": "日付",
    "amount_label": "金額",
    "description_label": "説明",
    "comments_label": "コメント"
  },
  "purchases_page": {
    "title": "仕入れ請求書",
    "add_purchase_bill": "新しい仕入れ請求書を追加",
    "no_purchase_bills": "まだ仕入れ請求書が記録されていません。最初の仕入れを追加してください！",
    "total_purchase_amount": "仕入れ合計金額",
    "daily_purchase_trend": "毎日の仕入れ傾向"
  },
  "purchase_bill_list": {
    "date": "日付",
    "amount": "金額",
    "description": "説明",
    "comments": "コメント",
    "actions": "操作"
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/messages/en.json
TYPE: json
CONTENT:
```
{
  "login": {
    "title": "Login to Phulkas App",
    "username_label": "Username",
    "password_label": "Password",
    "login_button": "Sign In",
    "login_error": "Login failed. Please check your credentials."
  },
  "auth": {
    "unauthenticated": "Please log in to view this page",
    "login_failed": "Login failed. Please check your credentials."
  },
  "layout": {
    "app_title": "Earning App",
    "dashboard_link": "Dashboard",
    "summary_link": "Summary",
    "purchases_link": "Purchases",
    "sign_out_button": "Sign Out"
  },
  "language_switcher": {
    "label": "Language",
    "en": "English",
    "ja": "Japanese"
  },
  "summary": {
    "title": "Earnings Summary",
    "summary_title": "Earnings Summary & Analytics",
    "from_date": "From Date",
    "to_date": "To Date",
    "apply_filter": "Apply Filter",
    "total_earnings": "Total Earnings",
    "daily_earnings_chart": "Daily Earnings",
    "meal_type_distribution_chart": "Meal Type Distribution",
    "earnings": "Earnings",
    "daily_summary_for": "Daily Summary for {date}",
    "total_daily_earnings": "Total Daily Earnings: ¥{amount}",
    "no_bills_found": "No bills found for the selected date range.",
    "lunch_summary_title": "Lunch Summary",
    "dinner_summary_title": "Dinner Summary",
    "food_total": "Food Total",
    "drink_total": "Drink Total",
    "total_earnings_label": "Total Earnings",
    "is_our_food_label": "Our Food?",
    "num_people_working_label": "Number of People Working Dinner",
    "no_lunch_entries": "No Lunch Entries",
    "no_dinner_entries": "No Dinner Entries",
    "all_bills_in_range": "All Bills in Range"
  },
  "date_range_filter": {
    "from_date": "From Date",
    "to_date": "To Date",
    "apply_filter": "Apply Filter",
    "invalid_date_range": "Invalid date range. Please select valid dates.",
    "from_date_after_to_date": "From date cannot be after To date.",
    "dates_not_selected": "Please select both From and To dates.",
    "invalid_date_format": "Invalid date format. Please use YYYY-MM-DD."
  },
  "dashboard": {
    "title": "Dashboard",
    "todays_entries": "Today's Entries",
    "summary_for_date": "Summary for {date}",
    "lunch_summary": "Lunch Summary",
    "dinner_summary": "Dinner Summary",
    "day_total_earnings_header": "Day Total Earnings",
    "food_bills_total": "Food Bills Total: {amount}",
    "drink_bills_total": "Drink Bills Total: {amount}",
    "phulkas_lunch_earnings": "Lunch Earnings: {amount}",
    "phulkas_dinner_earnings": "Dinner Earnings: {amount}",
    "add_bill_entry": "Add New Bill Entry",
    "no_entries_today": "No entries for today.",
    "no_summary_data": "No summary data available for this period.",
    "no_bills": "No bills recorded yet. Add your first bill!",
    "edit_bill_title": "Edit Bill",
    "add_bill_title": "Add New Bill",
    "date_label": "Date",
    "meal_type_label": "Meal Type",
    "food_amount_label": "Food Amount",
    "drink_amount_label": "Drink Amount",
    "is_our_food_label": "Our Food?",
    "num_people_working_label": "Number of People Working Dinner",
    "greeting": "Hello!",
    "welcome_message": "Welcome to your earning dashboard."
  },
  "meal_type": {
    "lunch": "Lunch",
    "dinner": "Dinner"
  },
  "earnings_details": {
    "lunch_food_base_income": "Lunch Food Base Income: {base}",
    "lunch_food_overage": " (+Overage: {overage} / 2 = {overageHalf})",
    "total_lunch_food_income_share": "Total Lunch Food Income Share: {amount}",
    "drink_calc_lunch": "Drinks Share (Lunch): {total} * {percentage}% = {share}",
    "dinner_food_direct_share": "Dinner Food Direct Share (if Our Food): {share} (from Raw {total})",
    "dinner_common_pool_contrib_food": "Food Contrib to Common Pool: {amount}",
    "dinner_common_pool_contrib_drinks": "Drink Contrib to Common Pool: {amount}",
    "total_common_pool": "Total Common Pool: {amount}",
    "our_common_pool_share": "Our Common Pool Share: {amount} ({workers} worker(s))"
  },
  "bill_list": {
    "date": "Date",
    "meal_type": "Meal Type",
    "food_amount": "Food",
    "drink_amount": "Drinks",
    "is_our_food": "Our Food?",
    "num_people_working": "Workers",
    "actions": "Actions",
    "edit": "Edit",
    "delete": "Delete",
    "comments": "Comments"
  },
  "edit": {
    "delete_confirm_title": "Confirm Deletion",
    "delete_confirm_message": "Are you sure you want to delete bill ID {id}?",
    "cancel": "Cancel",
    "delete": "Delete",
    "deleting": "Deleting bill...",
    "delete_bill_error": "Failed to delete bill: {error}"
  },
  "errors": {
    "failed_fetch": "Failed to fetch data. Please try again.",
    "bill_not_found": "Bill not found.",
    "required": "This field is required",
    "invalid_date": "Invalid date format",
    "positive_number": "Must be a positive number",
    "invalid_date_range": "Invalid date range selected.",
    "date_range_order": "From date cannot be after To date.",
    "bill_not_found_for_date": "No bills found for this date.",
    "form_validation_failed": "Please correct the errors in the form.",
    "no_purchase_bills_found": "No purchase bills found for the selected date range."
  },
  "bill_form": {
    "add_title": "Add New Bill",
    "edit_title": "Edit Bill",
    "date_label": "Date",
    "meal_type_label": "Meal Type",
    "lunch_option": "Lunch",
    "dinner_option": "Dinner",
    "food_amount_label": "Food Amount",
    "drink_amount_label": "Drink Amount",
    "is_our_food_label": "Is Our Food?",
    "num_people_working_label": "Number of People Working Dinner",
    "save_button": "Save Bill",
    "cancel_button": "Cancel",
    "add_success": "Bill added successfully!",
    "edit_success": "Bill updated successfully!",
    "add_error": "Failed to add bill: {error}",
    "edit_error": "Failed to update bill: {error}",
    "num_people_min": "Number of people working must be at least 1.",
    "comments_label": "Comments"
  },
  "general": {
    "currency": "¥",
    "yes": "Yes",
    "no": "No",
    "close": "Close",
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit_button": "Edit",
    "from_date": "From Date",
    "to_date": "To Date",
    "bills": "bills"
  },
  "purchase_bill_form": {
    "add_title": "Add New Purchase Bill",
    "edit_title": "Edit Purchase Bill",
    "date_label": "Date",
    "amount_label": "Amount",
    "description_label": "Description",
    "comments_label": "Comments"
  },
  "purchases_page": {
    "title": "Purchase Bills",
    "add_purchase_bill": "Add New Purchase Bill",
    "no_purchase_bills": "No purchase bills recorded yet. Add your first purchase!",
    "total_purchase_amount": "Total Purchase Amount",
    "daily_purchase_trend": "Daily Purchase Trend"
  },
  "purchase_bill_list": {
    "date": "Date",
    "amount": "Amount",
    "description": "Description",
    "comments": "Comments",
    "actions": "Actions"
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/types/Bill.ts
TYPE: typescript
CONTENT:
```
// src/types/Bill.ts
export interface Bill {
  id: string;
  date: string; // ISO string 'yyyy-MM-dd'
  foodAmount: number;
  drinkAmount: number;
  mealType: 'lunch' | 'dinner';
  isOurFood: boolean;
  numberOfPeopleWorkingDinner: number;
  comments: string | "";
}
```
--- FILE_END ---

--- FILE_START ---
PATH: src/context/ThemeContext.tsx
TYPE: typescript-react
CONTENT:
```
// src/context/ThemeContext.tsx
"use client"; // This directive MUST be at the very top

import React, { createContext, useContext, useState, useMemo, ReactNode } from 'react';
import { ThemeProvider, createTheme, PaletteMode } from '@mui/material';
import CssBaseline from '@mui/material/CssBaseline';
import { red } from '@mui/material/colors'; // Example import if you use specific colors

// Define the shape of the context value
interface ThemeContextType {
  currentTheme: PaletteMode; // 'light' or 'dark'
  toggleTheme: () => void;
}

// Create the context with a default undefined value
// createContext should only be called in client components
const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

// Custom hook to easily access the theme context
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    // This hook must be used within a ThemeProvider
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

// Theme provider component
interface AppThemeProviderProps { // Renamed from ThemeProviderProps to avoid potential conflicts
  children: ReactNode;
}

export const AppThemeProvider: React.FC<AppThemeProviderProps> = ({ children }) => {
  // State to manage the current theme mode ('light' or 'dark')
  const [mode, setMode] = useState<PaletteMode>('light'); // Default to light theme

  // Function to toggle the theme mode
  const toggleTheme = () => {
    setMode((prevMode) => (prevMode === 'light' ? 'dark' : 'light'));
  };

  // Memoize the theme object to avoid unnecessary re-creations
  const theme = useMemo(
    () =>
      createTheme({
        palette: {
          mode, // Use the current mode
          // You can customize your palette further here
          // primary: {
          //   main: '#556cd6',
          // },
          // secondary: {
          //   main: '#19857b',
          // },
          // error: {
          //   main: red.A400, // Example using imported color
          // },
        },
      }),
    [mode], // Recreate theme only when mode changes
  );

  // Memoize the context value
  const contextValue = useMemo(() => ({ currentTheme: mode, toggleTheme }), [mode]);

  return (
    <ThemeContext.Provider value={contextValue}>
      <ThemeProvider theme={theme}>
        {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}
        <CssBaseline />
        {children}
      </ThemeProvider>
    </ThemeContext.Provider>
  );
};

// Remember to wrap your root layout (app/layout.tsx) with <AppThemeProvider>
// to make the theme context available throughout your application.

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/layout.tsx
TYPE: typescript-react
CONTENT:
```
// src/app/layout.tsx

import { Inter } from "next/font/google";
import "./globals.css";
import type { Metadata } from "next";
import getRequestConfig from '@/i18n/request';
import { getLocale } from 'next-intl/server';
import { AuthProvider } from '@/components/AuthProvider';
import ThemeProviderWrapper from '@/components/ThemeProviderWrapper';
import MuiRegistry from '@/components/MuiRegistry';
import NextIntlClientProviderWrapper from '@/components/NextIntlClientProviderWrapper';

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Earning App",
  description: "Track daily earnings",
};

export default async function RootLayout({
  children,
  params: { locale: rootLocaleParam },
}: Readonly<{
  children: React.ReactNode;
  params: { locale: string };
}>) {

  const currentRequestLocale = rootLocaleParam || await getLocale();
  const { locale, messages, timeZone } = await getRequestConfig({ requestLocale: currentRequestLocale });

  return (
    <html lang={locale}>
      <head>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
      </head>
      <body className={inter.className}>
        <AuthProvider>
          <MuiRegistry>
            <ThemeProviderWrapper>
              {/* CRITICAL FIX: Pass the locale prop here */}
              <NextIntlClientProviderWrapper messages={messages} timeZone={timeZone} locale={locale}>
                {children}
              </NextIntlClientProviderWrapper>
            </ThemeProviderWrapper>
          </MuiRegistry>
        </AuthProvider>
      </body>
    </html>
  );
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/page.tsx
TYPE: typescript-react
CONTENT:
```
// src/app/page.tsx
import { redirect } from 'next/navigation';

// This is a Server Component that redirects based on locale negotiation or default
export default function RootPage() {
  // You could add logic here to detect user's preferred locale (e.g., from headers)
  // For simplicity, we'll just redirect to the default locale /en
  redirect('/en');
}
```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/layout.tsx
TYPE: typescript-react
CONTENT:
```
// src/app/[locale]/layout.tsx

import { notFound } from 'next/navigation';
import { routing } from '@/i18n/routing';
import Layout from '@/components/Layout'; // Assuming this is your main layout component

export default async function LocaleLayout(props: Readonly<{
  children: React.ReactNode;
  params: { locale: string };
}>) {
  const { children, params } = props;
  const { locale } = params; // Access locale directly, should be fine here

  const locales = routing.locales;
  if (!locales.includes(locale as any)) notFound();

  return (
    <Layout> {/* This should wrap your main content, including the menu/header */}
      {children}
    </Layout>
  );
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/page.tsx
TYPE: typescript-react
CONTENT:
```
// In your page.tsx
import { getServerSession } from "next-auth";
import { authOptions } from "@/auth";
import { redirect } from "next/navigation";
import LoginPageClient from "@/components/LoginPageClient";

export default async function LoginPage() {
  const session = await getServerSession(authOptions);

  if (session) {
    redirect("/en/dashboard");
  }

  return <LoginPageClient />;
}
```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/ClientLayout.tsx
TYPE: typescript-react
CONTENT:
```
// src/app/[locale]/ClientLayout.tsx
"use client"; // This directive MUST be the very first line

import { ReactNode } from 'react';
import { Session } from 'next-auth';
// Import our local client-side SessionProvider wrapper
import { SessionProvider } from '@/components/SessionProvider';

interface ClientLayoutProps {
  children: ReactNode;
  session: Session | null;
}

export default function ClientLayout({ children, session }: ClientLayoutProps) {
  return (
    <SessionProvider session={session}>
      {children}
    </SessionProvider>
  );
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/purchases/page.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useEffect, useState, useCallback, useMemo } from 'react'; // Added useCallback
import { useSession } from 'next-auth/react';
import { useParams, useRouter } from 'next/navigation';
import {
  Box, Typography, CircularProgress, Alert, Button, Dialog, DialogTitle,
  DialogContent, IconButton, DialogActions, DialogContentText, Paper,
  useTheme
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import PurchaseBillForm from '@/components/PurchaseBillForm';
import PurchaseBillList from '@/components/PurchaseBillList';
import { useTranslations } from 'next-intl';
import { format, parseISO, isValid, startOfMonth, endOfMonth } from 'date-fns';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { enUS, ja } from 'date-fns/locale';
import { BarChart, Bar, XAxis, YAxis, Tooltip, CartesianGrid, ResponsiveContainer } from 'recharts';

interface PurchaseBill {
  id: string;
  date: string;
  amount: number;
  description: string;
  comments?: string | null;
}

const PurchasesPageClient: React.FC = () => {
  const { data: session, status } = useSession();
  const router = useRouter();
  const params = useParams();
  const locale = params.locale as string;

  const t = useTranslations('purchases_page');
  const tGeneral = useTranslations('general');
  const tPurchaseBillForm = useTranslations('purchase_bill_form');
  const tEdit = useTranslations('edit');
  const tErrors = useTranslations('errors');

  const theme = useTheme();

  const [allPurchaseBills, setAllPurchaseBills] = useState<PurchaseBill[]>([]);
  const [filteredPurchaseBills, setFilteredPurchaseBills] = useState<PurchaseBill[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingPurchaseBill, setEditingPurchaseBill] = useState<PurchaseBill | undefined>(undefined);
  const [isModalLoading, setIsModalLoading] = useState(false);

  const [openConfirmDelete, setOpenConfirmDelete] = useState(false);
  const [purchaseBillToDeleteId, setPurchaseBillToDeleteId] = useState<string | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [deleteError, setDeleteError] = useState<string | null>(null);

  const [startDate, setStartDate] = useState<Date | null>(startOfMonth(new Date()));
  const [endDate, setEndDate] = useState<Date | null>(endOfMonth(new Date()));

  const dateFnsLocale = useMemo(() => {
    return locale === 'ja' ? ja : enUS;
  }, [locale]);

  const fetchPurchaseBills = useCallback(async (from?: Date | null, to?: Date | null) => {
    if (status !== 'authenticated') {
      setLoading(false);
      return;
    }

    setLoading(true);
    setError(null);

    let url = `/${locale}/api/purchase-bills`;
    const queryParams = new URLSearchParams();

    if (from && isValid(from)) {
      queryParams.append('from', format(from, 'yyyy-MM-dd'));
    }
    if (to && isValid(to)) {
      queryParams.append('to', format(to, 'yyyy-MM-dd'));
    }

    if (queryParams.toString()) {
      url += `?${queryParams.toString()}`;
    }

    try {
      const res = await fetch(url);
      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || tErrors('failed_fetch'));
      }
      const data: PurchaseBill[] = await res.json();
      const processedData = data.map(pb => ({
        ...pb,
        date: format(new Date(pb.date), 'yyyy-MM-dd'),
        amount: parseFloat(pb.amount.toString()),
        comments: pb.comments ?? null
      }));
      setAllPurchaseBills(processedData);
      setFilteredPurchaseBills(processedData);
    } catch (err: any) {
      setError(err.message || tErrors('failed_fetch'));
      setAllPurchaseBills([]);
      setFilteredPurchaseBills([]);
    } finally {
      setLoading(false);
    }
  }, [status, locale, tErrors]);

  useEffect(() => {
    if (status === 'loading') return;
    if (status === 'unauthenticated') {
      router.push(`/${locale}`);
    } else {
      fetchPurchaseBills(startDate, endDate);
    }
  }, [status, router, locale, fetchPurchaseBills, startDate, endDate]);

  const totalPurchaseAmount = useMemo(() => {
    return filteredPurchaseBills.reduce((sum, bill) => sum + bill.amount, 0);
  }, [filteredPurchaseBills]);

  const chartData = useMemo(() => {
    const groupedData: { [key: string]: number } = {};
    filteredPurchaseBills.forEach(bill => {
      const dateKey = format(parseISO(bill.date), 'yyyy-MM-dd');
      groupedData[dateKey] = (groupedData[dateKey] || 0) + bill.amount;
    });

    const dataArray = Object.keys(groupedData).sort().map(date => ({
      date,
      amount: groupedData[date],
    }));
    return dataArray;
  }, [filteredPurchaseBills]);


  const handleCloseModal = useCallback(() => { // Using useCallback
    setIsModalOpen(false);
    setEditingPurchaseBill(undefined);
    setError(null);
  }, []);

  const handleOpenAddModal = useCallback(() => { // Using useCallback
    setEditingPurchaseBill(undefined);
    setIsModalOpen(true);
    setIsModalLoading(false);
  }, []);

  const handleOpenEditModal = useCallback(async (purchaseBillId: string) => { // Using useCallback
    setIsModalOpen(true);
    setIsModalLoading(true);
    try {
      const response = await fetch(`/${locale}/api/purchase-bills/${purchaseBillId}`);
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || tErrors('failed_fetch'));
      }
      const data: PurchaseBill = await response.json();
      const formattedData = {
        ...data,
        date: format(new Date(data.date), 'yyyy-MM-dd'),
        amount: parseFloat(data.amount.toString()),
        comments: data.comments ?? null
      };
      setEditingPurchaseBill(formattedData);
    } catch (err: any) {
      setError(err.message || tErrors('failed_fetch'));
      handleCloseModal();
    } finally {
      setIsModalLoading(false);
    }
  }, [locale, tErrors, handleCloseModal]);

  const handlePurchaseBillFormSubmit = useCallback(async (formData: Omit<PurchaseBill, 'id'>, currentId?: string) => { // Using useCallback
    setIsModalLoading(true);
    setError(null);

    const method = currentId ? 'PUT' : 'POST';
    const url = currentId ? `/${locale}/api/purchase-bills/${currentId}` : `/${locale}/api/purchase-bills`;

    try {
      const res = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || tErrors('failed_fetch'));
      }

      handleCloseModal();
      fetchPurchaseBills(startDate, endDate);

    } catch (err: any) {
      setError(err.message || (currentId ? tPurchaseBillForm('edit_error') : tPurchaseBillForm('add_error')));
    } finally {
      setIsModalLoading(false);
    }
  }, [locale, tErrors, tPurchaseBillForm, handleCloseModal, fetchPurchaseBills, startDate, endDate]);

  const handleOpenConfirmDelete = useCallback((id: string) => { // Using useCallback
    setPurchaseBillToDeleteId(id);
    setOpenConfirmDelete(true);
    setDeleteError(null);
  }, []);

  const handleCloseConfirmDelete = useCallback(() => { // Using useCallback
    setOpenConfirmDelete(false);
    setPurchaseBillToDeleteId(null);
    setDeleteError(null);
  }, []);

  const handleDeletePurchaseBill = useCallback(async () => { // Using useCallback
    if (purchaseBillToDeleteId === null) return;

    setOpenConfirmDelete(false);
    setIsDeleting(true);
    setDeleteError(null);

    try {
      const res = await fetch(`/${locale}/api/purchase-bills/${purchaseBillToDeleteId}`, {
        method: 'DELETE',
      });

      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || tEdit('delete_bill_error', { error: '' }));
      }

      setPurchaseBillToDeleteId(null);
      fetchPurchaseBills(startDate, endDate);

    } catch (err: any) {
      setDeleteError(err.message || tErrors('failed_fetch'));
    } finally {
      setIsDeleting(false);
    }
  }, [purchaseBillToDeleteId, locale, tEdit, tErrors, fetchPurchaseBills, startDate, endDate]);

  const handleDateChange = useCallback((newStartDate: Date | null, newEndDate: Date | null) => { // Using useCallback
    if (newStartDate && newEndDate && newStartDate > newEndDate) {
      setError(tErrors('date_range_order'));
      return;
    }
    setError(null);
    setStartDate(newStartDate);
    setEndDate(newEndDate);
  }, [tErrors]);


  if (status === 'loading' || loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '80vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (status === 'unauthenticated') {
    return (
      <Alert severity="warning" sx={{ mt: 2 }}>
        {tGeneral('auth.unauthenticated')}
      </Alert>
    );
  }

  return (
    <Box sx={{ p: 3 }}>
      <Typography variant="h4" gutterBottom>
        {t('title')}
      </Typography>

      {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
      {deleteError && <Alert severity="error" sx={{ mb: 2 }}>{deleteError}</Alert>}
      {isDeleting && <Alert severity="info" sx={{ mb: 2 }}>{tEdit('deleting')}</Alert>}

      <Box sx={{ mb: 3, display: 'flex', gap: 2, flexWrap: 'wrap', alignItems: 'center' }}>
        <Button variant="contained" onClick={handleOpenAddModal}>
          {t('add_purchase_bill')}
        </Button>

        <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={dateFnsLocale}>
          <DatePicker
            label={tGeneral('from_date')}
            value={startDate}
            onChange={(date) => handleDateChange(date, endDate)}
            slotProps={{ textField: { size: "small", error: !!error, helperText: error } }}
            format="yyyy-MM-dd"
          />
          <DatePicker
            label={tGeneral('to_date')}
            value={endDate}
            onChange={(date) => handleDateChange(startDate, date)}
            slotProps={{ textField: { size: "small", error: !!error, helperText: error } }}
            format="yyyy-MM-dd"
          />
        </LocalizationProvider>
      </Box>

      {/* Total Purchase Amount Display */}
      {!loading && (
        <Paper elevation={2} sx={{ p: 2, mb: 2, borderRadius: 2 }}>
          <Typography variant="h6" gutterBottom>
            {t('total_purchase_amount')}
          </Typography>
          <Typography variant="body1" color="primary">
            {tGeneral('currency')}{totalPurchaseAmount.toLocaleString()}
          </Typography>
        </Paper>
      )}

      {/* Bar Chart for Trend */}
      {!loading && chartData.length > 0 && (
        <Paper elevation={2} sx={{ p: 2, mb: 3, borderRadius: 2 }}>
          <Typography variant="h6" gutterBottom>
            {t('daily_purchase_trend')}
          </Typography>
          <ResponsiveContainer width="100%" height={300}>
            <BarChart data={chartData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip formatter={(value: number) => `${tGeneral('currency')}${value.toLocaleString()}`} />
              <Bar dataKey="amount" fill={theme.palette.primary.main} />
            </BarChart>
          </ResponsiveContainer>
        </Paper>
      )}

      {filteredPurchaseBills.length > 0 ? (
        <PurchaseBillList
          purchaseBills={filteredPurchaseBills}
          onEdit={handleOpenEditModal}
          onDelete={handleOpenConfirmDelete}
        />
      ) : (
        <Typography sx={{ mt: 2 }}>
          {t('no_purchase_bills')}
        </Typography>
      )}

      {/* Purchase Bill Form Modal */}
      <Dialog open={isModalOpen} onClose={handleCloseModal} fullWidth maxWidth="sm">
        <DialogTitle>
          {editingPurchaseBill ? tPurchaseBillForm('edit_title') : tPurchaseBillForm('add_title')}
          <IconButton
            aria-label="close"
            onClick={handleCloseModal}
            sx={{
              position: 'absolute',
              right: 8,
              top: 8,
              color: (theme) => theme.palette.grey[500],
            }}
          >
            <CloseIcon />
          </IconButton>
        </DialogTitle>
        <DialogContent dividers>
          <PurchaseBillForm
            key={editingPurchaseBill?.id || 'add-purchase-bill-form'}
            initialPurchaseBill={editingPurchaseBill}
            onSubmit={handlePurchaseBillFormSubmit}
            isSubmitting={isModalLoading}
            defaultDate={startDate || new Date()}
            onCancel={handleCloseModal}
          />
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog for Purchase Bills */}
      <Dialog
        open={openConfirmDelete}
        onClose={handleCloseConfirmDelete}
        aria-labelledby="purchase-delete-dialog-title"
        aria-describedby="purchase-delete-dialog-description"
      >
        <DialogTitle id="purchase-delete-dialog-title">{tEdit('delete_confirm_title')}</DialogTitle>
        <DialogContent>
          <DialogContentText id="purchase-delete-dialog-description">
            {tEdit('delete_confirm_message', { id: purchaseBillToDeleteId ?? '' })}
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseConfirmDelete} disabled={isDeleting}>{tGeneral('cancel')}</Button>
          <Button onClick={handleDeletePurchaseBill} color="error" autoFocus disabled={isDeleting}>
            {isDeleting ? <CircularProgress size={24} /> : tGeneral('delete')}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default PurchasesPageClient;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/config/page.tsx
TYPE: typescript-react
CONTENT:
```
// src/app/[locale]/config/page.tsx
import { NextIntlClientProvider } from 'next-intl';
import { notFound } from 'next/navigation';
import { getTranslations } from 'next-intl/server'; // Use getTranslations for server components
import ConfigPageClient from '@/components/ConfigPageClient';

export async function generateStaticParams() {
  return [{ locale: 'en' }, { locale: 'ja' }];
}

export default async function Page(props: { params: { locale: string } }) {
  const { locale } = props.params;

  let messages;
  try {
    messages = (await import(`../../../messages/${locale}.json`)).default;
  } catch (error) {
    notFound();
  }

  // Fetch translations on the server side
  const t = await getTranslations('config_page', { locale });

  return (
    <NextIntlClientProvider locale={locale} messages={messages}>
      <ConfigPageClient title={t('title')} />
    </NextIntlClientProvider>
  );
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/dashboard/page.tsx
TYPE: typescript-react
CONTENT:
```
// src/app/[locale]/dashboard/page.tsx
import { getServerSession } from "next-auth";
import { authOptions } from "@/auth";
import { redirect } from "next/navigation";
import DashboardPageClient from "@/components/DashboardPageClient";

interface DashboardPageProps {
  params: {
    locale: string;
  };
}

export default async function DashboardPage(props: DashboardPageProps) {
  const session = await getServerSession(authOptions);

  const { locale } = await props.params; // Access locale directly

  if (!session) {
    redirect(`/${locale}`);
  }

  return <DashboardPageClient locale={locale} />;
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/api/bills/route.ts
TYPE: typescript
CONTENT:
```
// src/app/[locale]/api/bills/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/auth';
import prisma from '@/lib/prisma';
import { MealType } from '@prisma/client';

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const { date, foodAmount, drinkAmount, mealType, isOurFood, numberOfPeopleWorkingDinner, comments } = body;

    if (!date || foodAmount === undefined || drinkAmount === undefined || !mealType || isOurFood === undefined || numberOfPeopleWorkingDinner === undefined) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    const prismaMealType = mealType.toUpperCase() as MealType;

    const newBill = await prisma.bill.create({
      data: {
        date: new Date(date),
        foodAmount: parseFloat(foodAmount),
        drinkAmount: parseFloat(drinkAmount),
        mealType: prismaMealType,
        isOurFood: isOurFood,
        numberOfPeopleWorkingDinner: numberOfPeopleWorkingDinner,
        comments: comments,
      },
    });

    return NextResponse.json(newBill, { status: 201 });
  } catch (error) {
    console.error('API Error creating bill:', error);
    return NextResponse.json({ error: 'Failed to create bill' }, { status: 500 });
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/api/bills/[id]/route.ts
TYPE: typescript
CONTENT:
```
// src/app/[locale]/api/bills/[id]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/auth';
import prisma from '@/lib/prisma';
import { MealType } from '@prisma/client';

interface RouteParams {
  params: {
    id: string;
  };
}

export async function PUT(request: Request, { params }: RouteParams) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = params;

  try {
    const body = await request.json();
    const { date, foodAmount, drinkAmount, mealType, isOurFood, numberOfPeopleWorkingDinner, comments } = body;

    if (!date || foodAmount === undefined || drinkAmount === undefined || !mealType || isOurFood === undefined || numberOfPeopleWorkingDinner === undefined) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    const prismaMealType = mealType.toUpperCase() as MealType;

    const updatedBill = await prisma.bill.update({
      where: {
        id: parseInt(id),
      },
      data: {
        date: new Date(date),
        foodAmount: parseFloat(foodAmount),
        drinkAmount: parseFloat(drinkAmount),
        mealType: prismaMealType,
        isOurFood: isOurFood,
        numberOfPeopleWorkingDinner: numberOfPeopleWorkingDinner,
        comments: comments,
      },
    });

    return NextResponse.json(updatedBill, { status: 200 });
  } catch (error) {
    console.error(`API Error updating bill with ID ${id}:`, error);
    return NextResponse.json({ error: 'Failed to update bill' }, { status: 500 });
  }
}

export async function GET(request: Request, { params }: RouteParams) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = params;

  try {
    const bill = await prisma.bill.findUnique({
      where: {
        id: parseInt(id),
      },
    });

    if (!bill) {
      return NextResponse.json({ error: 'Bill not found' }, { status: 404 });
    }

    return NextResponse.json(bill, { status: 200 });
  } catch (error) {
    console.error(`API Error fetching bill with ID ${id}:`, error);
    return NextResponse.json({ error: 'Failed to fetch bill' }, { status: 500 });
  }
}

export async function DELETE(request: Request, { params }: RouteParams) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = params;

  try {
    await prisma.bill.delete({
      where: {
        id: parseInt(id),
      },
    });

    return NextResponse.json({ message: 'Bill deleted successfully' }, { status: 200 });
  } catch (error) {
    console.error(`API Error deleting bill with ID ${id}:`, error);
    return NextResponse.json({ error: 'Failed to delete bill' }, { status: 500 });
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/api/purchase-bills/route.ts
TYPE: typescript
CONTENT:
```
// src/app/[locale]/api/purchase-bills/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/auth';
import prisma from '@/lib/prisma';
import { format, parseISO, isValid } from 'date-fns';

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();
    const { date, amount, description, comments } = body;

    if (!date || amount === undefined || !description) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    const newPurchaseBill = await prisma.purchaseBill.create({
      data: {
        date: new Date(date),
        amount: parseFloat(amount),
        description,
        comments,
      },
    });

    return NextResponse.json(newPurchaseBill, { status: 201 });
  } catch (error) {
    console.error('API Error creating purchase bill:', error);
    return NextResponse.json({ error: 'Failed to create purchase bill' }, { status: 500 });
  }
}

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const fromParam = searchParams.get('from');
  const toParam = searchParams.get('to');

  let whereClause: any = {};

  if (fromParam && isValid(parseISO(fromParam))) {
    const fromDate = parseISO(fromParam);
    fromDate.setUTCHours(0, 0, 0, 0);
    whereClause.date = { gte: fromDate };
  }

  if (toParam && isValid(parseISO(toParam))) {
    const toDate = parseISO(toParam);
    toDate.setUTCHours(23, 59, 59, 999);
    whereClause.date = { ...whereClause.date, lte: toDate };
  }

  try {
    const purchaseBills = await prisma.purchaseBill.findMany({
      where: whereClause,
      orderBy: {
        date: 'asc',
      },
    });
    return NextResponse.json(purchaseBills, { status: 200 });
  } catch (error) {
    console.error('API Error fetching purchase bills:', error);
    return NextResponse.json({ error: 'Failed to fetch purchase bills' }, { status: 500 });
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/api/purchase-bills/by-date/route.ts
TYPE: typescript
CONTENT:
```
// src/app/[locale]/api/purchase-bills/by-date/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/auth';
import prisma from '@/lib/prisma';

export async function GET(request: Request) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const dateParam = searchParams.get('date');

  if (!dateParam) {
    return NextResponse.json({ error: 'Date parameter is required' }, { status: 400 });
  }

  try {
    const startOfDay = new Date(dateParam);
    startOfDay.setUTCHours(0, 0, 0, 0);

    const endOfDay = new Date(dateParam);
    endOfDay.setUTCHours(23, 59, 59, 999);

    const purchaseBills = await prisma.purchaseBill.findMany({
      where: {
        date: {
          gte: startOfDay,
          lte: endOfDay,
        },
      },
      orderBy: {
        date: 'asc',
      },
    });

    return NextResponse.json(purchaseBills, { status: 200 });
  } catch (error) {
    console.error('API Error fetching purchase bills by date:', error);
    return NextResponse.json({ error: 'Failed to fetch purchase bills' }, { status: 500 });
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/api/purchase-bills/[id]/route.ts
TYPE: typescript
CONTENT:
```
// src/app/[locale]/api/purchase-bills/[id]/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/auth';
import prisma from '@/lib/prisma';

interface RouteParams {
  params: {
    id: string;
  };
}

// GET a single Purchase Bill by ID
export async function GET(request: Request, { params }: RouteParams) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = params;

  try {
    const purchaseBill = await prisma.purchaseBill.findUnique({
      where: {
        id: parseInt(id), // Assuming ID is an integer
      },
    });

    if (!purchaseBill) {
      return NextResponse.json({ error: 'Purchase bill not found' }, { status: 404 });
    }

    return NextResponse.json(purchaseBill, { status: 200 });
  } catch (error) {
    console.error(`API Error fetching purchase bill with ID ${id}:`, error);
    return NextResponse.json({ error: 'Failed to fetch purchase bill' }, { status: 500 });
  }
}

// PUT (Update) a Purchase Bill by ID
export async function PUT(request: Request, { params }: RouteParams) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = params;

  try {
    const body = await request.json();
    const { date, amount, description, comments } = body;

    if (!date || amount === undefined || !description) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    const updatedPurchaseBill = await prisma.purchaseBill.update({
      where: {
        id: parseInt(id),
      },
      data: {
        date: new Date(date),
        amount: parseFloat(amount),
        description,
        comments,
      },
    });

    return NextResponse.json(updatedPurchaseBill, { status: 200 });
  } catch (error) {
    console.error(`API Error updating purchase bill with ID ${id}:`, error);
    return NextResponse.json({ error: 'Failed to update purchase bill' }, { status: 500 });
  }
}

// DELETE a Purchase Bill by ID
export async function DELETE(request: Request, { params }: RouteParams) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { id } = params;

  try {
    await prisma.purchaseBill.delete({
      where: {
        id: parseInt(id),
      },
    });

    return NextResponse.json({ message: 'Purchase bill deleted successfully' }, { status: 200 });
  } catch (error) {
    console.error(`API Error deleting purchase bill with ID ${id}:`, error);
    return NextResponse.json({ error: 'Failed to delete purchase bill' }, { status: 500 });
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/api/reports/route.ts
TYPE: typescript
CONTENT:
```
// src/app/[locale]/api/reports/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/auth';
import prisma from '@/lib/prisma';
import { parseISO, isValid } from 'date-fns';

// Define the type for the request parameters
interface RouteParams {
  params: {
    locale: string; // The locale from the URL path
  };
}

export async function GET(request: Request, { params }: RouteParams) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // The locale can be accessed from params.locale if needed for filtering/logging
  const { locale } = params; 
  // console.log(`API: Fetching reports for locale: ${locale}`); // Optional: for debugging

  const { searchParams } = new URL(request.url);
  const fromParam = searchParams.get('from');
  const toParam = searchParams.get('to');

  let fromDate: Date | undefined;
  let toDate: Date | undefined;

  // Robust date parsing
  if (fromParam) {
    const parsed = parseISO(fromParam);
    if (isValid(parsed)) {
      fromDate = parsed;
    } else {
      console.error(`API: Invalid 'from' date parameter for locale ${locale}: ${fromParam}`);
      return NextResponse.json({ error: 'Invalid "from" date format' }, { status: 400 });
    }
  }

  if (toParam) {
    const parsed = parseISO(toParam);
    if (isValid(parsed)) {
      // For 'to' date, adjust to include the entire day
      toDate = new Date(parsed.getFullYear(), parsed.getMonth(), parsed.getDate() + 1);
    } else {
      console.error(`API: Invalid 'to' date parameter for locale ${locale}: ${toParam}`);
      return NextResponse.json({ error: 'Invalid "to" date format' }, { status: 400 });
    }
  }

  if (!fromDate || !toDate) {
    return NextResponse.json({ error: 'Both "from" and "to" dates are required and must be valid.' }, { status: 400 });
  }

  try {
    const bills = await prisma.bill.findMany({
      where: {
        date: {
          gte: fromDate,
          lt: toDate,
        },
      },
      orderBy: {
        date: 'asc',
      },
    });

    // Ensure amounts are numbers before sending to client
    const safeBills = bills.map(bill => ({
      ...bill,
      foodAmount: typeof bill.foodAmount === 'string' ? parseFloat(bill.foodAmount) : Number(bill.foodAmount),
      drinkAmount: typeof bill.drinkAmount === 'string' ? parseFloat(bill.drinkAmount) : Number(bill.drinkAmount),
    }));

    return NextResponse.json({ bills: safeBills });
  } catch (error) {
    console.error(`API Error fetching bills for locale ${locale}:`, error);
    return NextResponse.json({ error: 'Failed to fetch bills' }, { status: 500 });
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/[locale]/summary/page.tsx
TYPE: typescript-react
CONTENT:
```
// src/app/[locale]/summary/page.tsx
import { getServerSession } from "next-auth";
import { authOptions } from "@/auth";
import { redirect } from "next/navigation";
import SummaryPageClient from "@/components/SummaryPageClient";
import prisma from '@/lib/prisma';
import { format, isValid } from 'date-fns';

// Define the Bill type to match Prisma's output and what calculations.ts expects
interface Bill {
  id: string;
  date: string; // ISO string 'yyyy-MM-dd'
  foodAmount: number; // Now explicitly foodAmount
  drinkAmount: number; // Now explicitly drinkAmount
  mealType: 'lunch' | 'dinner';
  isOurFood: boolean;
  numberOfPeopleWorkingDinner: number;
  comments?: string | null;
}

interface SummaryPageProps {
  params: {
    locale: string;
  };
  searchParams?: {
    from?: string;
    to?: string;
  };
}

export default async function SummaryPage(props: SummaryPageProps) {
  const session = await getServerSession(authOptions);

  const { locale } = await Promise.resolve(props.params);
  const currentSearchParams = await Promise.resolve(props.searchParams || {});

  if (!session) {
    redirect(`/${locale}`);
  }

  let bills: Bill[] = [];
  let error: string | null = null;
  let fromDate: Date | null = null;
  let toDate: Date | null = null;

  try {
    const fromParam = currentSearchParams.from;
    const toParam = currentSearchParams.to;

    // Determine date range for fetching
    if (fromParam && toParam) {
      fromDate = new Date(fromParam);
      toDate = new Date(toParam);

      if (isNaN(fromDate.getTime()) || !isValid(fromDate) || isNaN(toDate.getTime()) || !isValid(toDate)) {
        throw new Error("Invalid date format in URL parameters. Please use Букмекерлар-MM-DD.");
      }
      if (fromDate > toDate) {
        throw new Error("From date cannot be after To date.");
      }

      const adjustedToDate = new Date(toDate);
      adjustedToDate.setDate(adjustedToDate.getDate() + 1);

      const fetchedBillsRaw = await prisma.bill.findMany({
        where: {
          date: {
            gte: fromDate,
            lt: adjustedToDate,
          },
        },
        orderBy: {
          date: 'asc',
        },
      });

      bills = fetchedBillsRaw.map(bill => {
        // Ensure foodAmount and drinkAmount are numbers
        const foodAmountNum = typeof bill.foodAmount === 'string'
          ? parseFloat(bill.foodAmount)
          : Number(bill.foodAmount);
        const drinkAmountNum = typeof bill.drinkAmount === 'string'
          ? parseFloat(bill.drinkAmount)
          : Number(bill.drinkAmount);

        if (isNaN(foodAmountNum) || isNaN(drinkAmountNum)) {
          console.error('SummaryPage (Server): NaN amount detected for bill:', bill);
          throw new Error('Invalid foodAmount or drinkAmount found in bill data.');
        }

        return {
          id: bill.id,
          date: format(bill.date, 'yyyy-MM-dd'),
          mealType: bill.mealType.toString().toLowerCase() as 'lunch' | 'dinner',
          foodAmount: foodAmountNum, // Pass foodAmount directly
          drinkAmount: drinkAmountNum, // Pass drinkAmount directly
          isOurFood: bill.isOurFood ?? true,
          numberOfPeopleWorkingDinner: bill.numberOfPeopleWorkingDinner ?? 1,
          comments: bill.comments ?? null,
        };
      });

    } else {
      // Default date range (e.g., last 7 days) if no search params are provided
      const defaultToDate = new Date();
      const defaultFromDate = new Date();
      defaultFromDate.setDate(defaultFromDate.getDate() - 6);

      fromDate = defaultFromDate;
      toDate = defaultToDate;

      const adjustedDefaultToDate = new Date(defaultToDate);
      adjustedDefaultToDate.setDate(adjustedDefaultToDate.getDate() + 1);

      const fetchedBillsRaw = await prisma.bill.findMany({
        where: {
          date: {
            gte: defaultFromDate,
            lt: adjustedDefaultToDate,
          },
        },
        orderBy: {
          date: 'asc',
        },
      });

      bills = fetchedBillsRaw.map(bill => {
        const foodAmountNum = typeof bill.foodAmount === 'string'
          ? parseFloat(bill.foodAmount)
          : Number(bill.foodAmount);
        const drinkAmountNum = typeof bill.drinkAmount === 'string'
          ? parseFloat(bill.drinkAmount)
          : Number(bill.drinkAmount);

        if (isNaN(foodAmountNum) || isNaN(drinkAmountNum)) {
          console.error('SummaryPage (Server): NaN amount detected for default bill:', bill);
          throw new Error('Invalid foodAmount or drinkAmount found in default bill data.');
        }

        return {
          id: bill.id,
          date: format(bill.date, 'yyyy-MM-dd'),
          mealType: bill.mealType.toString().toLowerCase() as 'lunch' | 'dinner',
          foodAmount: foodAmountNum,
          drinkAmount: drinkAmountNum,
          isOurFood: bill.isOurFood ?? true,
          numberOfPeopleWorkingDinner: bill.numberOfPeopleWorkingDinner ?? 1,
          comments: bill.comments ?? null,
        };
      });
    }
  } catch (e: any) {
    console.error("SummaryPage (Server): Error fetching or processing bills:", e);
    error = e.message || "Failed to fetch summary data.";
    bills = []; // Ensure bills is empty on error
  }

  return (
    <SummaryPageClient
      locale={locale}
      initialBills={bills}
      initialFromDate={fromDate ? format(fromDate, 'yyyy-MM-dd') : undefined}
      initialToDate={toDate ? format(toDate, 'yyyy-MM-dd') : undefined}
      initialError={error}
    />
  );
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/api/config/route.ts
TYPE: typescript
CONTENT:
```
// src/app/api/config/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/auth'; // Assuming your auth options are here
import prisma from '@/lib/prisma'; // Assuming your Prisma client is here

/**
 * GET /api/config
 * Retrieves all application configuration settings.
 * Requires authentication.
 */
export async function GET() {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    // Fetch all configuration entries from the database
    const configEntries = await prisma.appConfiguration.findMany();

    // Transform the array of entries into a key-value object for easier consumption
    const configObject: Record<string, number> = configEntries.reduce((acc, entry) => {
      acc[entry.key] = entry.value;
      return acc;
    }, {});

    return NextResponse.json(configObject, { status: 200 });
  } catch (error) {
    console.error('API Error fetching app configuration:', error);
    return NextResponse.json({ error: 'Failed to fetch app configuration' }, { status: 500 });
  }
}

/**
 * PUT /api/config
 * Updates multiple application configuration settings.
 * Expects a JSON array of { key: string, value: number, description?: string } objects.
 * Requires authentication.
 */
export async function PUT(request: Request) {
  const session = await getServerSession(authOptions);

  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const body = await request.json();

    // Basic validation: Ensure body is an array
    if (!Array.isArray(body)) {
      return NextResponse.json({ error: 'Request body must be an array of configuration objects.' }, { status: 400 });
    }

    const updatedConfigs = [];
    for (const item of body) {
      const { key, value, description } = item;

      // Validate each item in the array
      if (typeof key !== 'string' || typeof value !== 'number' || (description !== undefined && typeof description !== 'string')) {
        return NextResponse.json({ error: `Invalid configuration item format: ${JSON.stringify(item)}` }, { status: 400 });
      }

      // Use upsert to create if not exists, or update if exists
      const updatedConfig = await prisma.appConfiguration.upsert({
        where: { key: key },
        update: { value: value, description: description },
        create: { key: key, value: value, description: description },
      });
      updatedConfigs.push(updatedConfig);
    }

    return NextResponse.json({ message: 'App configuration updated successfully', updatedConfigs }, { status: 200 });
  } catch (error) {
    console.error('API Error updating app configuration:', error);
    return NextResponse.json({ error: 'Failed to update app configuration' }, { status: 500 });
  }
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/app/api/auth/[...nextauth]/route.tsx
TYPE: typescript-react
CONTENT:
```
// src/app/api/auth/[...nextauth]/route.tsx
// Import GET and POST directly from your configured auth.ts file
import { GET, POST } from '@/auth';

// Re-export them to define your API route handlers for Next.js App Router
// Next.js automatically calls these exported functions for the corresponding HTTP methods.
export { GET, POST };

// You can also define other handlers like PUT, DELETE, etc., if needed, similarly.

```
--- FILE_END ---

--- FILE_START ---
PATH: src/config/app.ts
TYPE: typescript
CONTENT:
```
// src/config/app.ts
export const AppConfig = {
  LUNCH_FOOD_BASE_INCOME: 8000,
  LUNCH_FOOD_OVERAGE_SHARE_PERCENT: 0.5, // 50%
  LUNCH_DRINK_SHARE_PERCENT: 0.25, // 25%

  DINNER_FOOD_OUR_SHARE_PERCENT: 0.75, // 75%
  DINNER_FOOD_COMMON_POOL_PERCENT: 0.25, // 25%
  DINNER_DRINK_COMMON_POOL_PERCENT: 0.25, // 25% (for drinks)
};

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/AppConfigForm.tsx
TYPE: typescript-react
CONTENT:
```
// src/components/AppConfigForm.tsx
"use client";

import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  TextField,
  Button,
  Typography,
  CircularProgress,
  Alert,
  Paper,
  Grid,
} from '@mui/material';
import { useTranslations } from 'next-intl';

// Define the shape of the configuration items
interface ConfigItem {
  key: string;
  value: number;
  description?: string;
}

// Define the props for the component
interface AppConfigFormProps {
  onSaveSuccess?: () => void; // Optional callback for successful save
}

const AppConfigForm: React.FC<AppConfigFormProps> = ({ onSaveSuccess }) => {
  const t = useTranslations('config_form');
  const tErrors = useTranslations('errors');

  // State to hold the current configuration values
  const [config, setConfig] = useState<Record<string, number>>({});
  const [loading, setLoading] = useState<boolean>(true);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  // Descriptions for each config key (for display in the UI)
  const configDescriptions: Record<string, string> = {
    LUNCH_FOOD_BASE_INCOME: t('lunch_food_base_income_desc'),
    LUNCH_FOOD_OVERAGE_SHARE_PERCENT: t('lunch_food_overage_share_percent_desc'),
    LUNCH_DRINK_SHARE_PERCENT: t('lunch_drink_share_percent_desc'),
    DINNER_FOOD_OUR_SHARE_PERCENT: t('dinner_food_our_share_percent_desc'),
    DINNER_FOOD_COMMON_POOL_PERCENT: t('dinner_food_common_pool_percent_desc'),
    DINNER_DRINK_COMMON_POOL_PERCENT: t('dinner_drink_common_pool_percent_desc'),
  };

  // Fetch configuration on component mount
  useEffect(() => {
    const fetchConfig = async () => {
      setLoading(true);
      setError(null);
      setSuccess(null);
      try {
        const response = await fetch('/api/config');
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || tErrors('failed_fetch_config'));
        }
        const data = await response.json();
        setConfig(data);
      } catch (err: any) {
        console.error('Error fetching config:', err);
        setError(err.message || tErrors('failed_fetch_config'));
      } finally {
        setLoading(false);
      }
    };
    fetchConfig();
  }, [tErrors]);

  // Handle input changes for config values
  const handleChange = useCallback((key: string, value: string) => {
    setError(null); // Clear errors on change
    setSuccess(null); // Clear success on change
    setConfig((prevConfig) => ({
      ...prevConfig,
      [key]: value === '' ? '' : Number(value), // Allow empty string for temporary input state
    }));
  }, []);

  // Validate a single field
  const validateField = useCallback((key: string, value: number | string): string | null => {
    if (value === '' || value === null || value === undefined) {
      return tErrors('required');
    }
    const numValue = Number(value);
    if (isNaN(numValue)) {
      return tErrors('invalid_number');
    }
    if (key.includes('PERCENT') && (numValue < 0 || numValue > 1)) {
      return tErrors('percentage_range'); // For percentages, must be between 0 and 1
    }
    if (key === 'LUNCH_FOOD_BASE_INCOME' && numValue < 0) {
      return tErrors('positive_number');
    }
    return null;
  }, [tErrors]);

  // Handle form submission
  const handleSubmit = useCallback(async (event: React.FormEvent) => {
    event.preventDefault();
    setIsSubmitting(true);
    setError(null);
    setSuccess(null);

    const updatedConfigArray: ConfigItem[] = Object.keys(config).map((key) => ({
      key,
      value: Number(config[key]), // Ensure value is number for submission
      description: configDescriptions[key], // Include description for upsert
    }));

    // Perform client-side validation for all fields before submitting
    let hasValidationError = false;
    const newErrors: Record<string, string> = {};
    for (const item of updatedConfigArray) {
      const fieldError = validateField(item.key, item.value);
      if (fieldError) {
        newErrors[item.key] = fieldError;
        hasValidationError = true;
      }
    }

    if (hasValidationError) {
      setError(tErrors('form_validation_failed'));
      setIsSubmitting(false);
      return;
    }

    try {
      const response = await fetch('/api/config', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updatedConfigArray),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || tErrors('failed_update_config'));
      }

      setSuccess(t('update_success'));
      if (onSaveSuccess) {
        onSaveSuccess();
      }
    } catch (err: any) {
      console.error('Error updating config:', err);
      setError(err.message || tErrors('failed_update_config'));
    } finally {
      setIsSubmitting(false);
    }
  }, [config, configDescriptions, onSaveSuccess, t, tErrors, validateField]);

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 200 }}>
        <CircularProgress />
        <Typography sx={{ ml: 2 }}>{t('loading_config')}</Typography>
      </Box>
    );
  }

  return (
    <Paper elevation={3} sx={{ p: 4, borderRadius: 3 }}>
      <Typography variant="h5" component="h2" gutterBottom sx={{ mb: 3 }}>
        {t('title')}
      </Typography>

      {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
      {success && <Alert severity="success" sx={{ mb: 2 }}>{success}</Alert>}

      <Box component="form" onSubmit={handleSubmit}>
        <Grid container spacing={3}>
          {Object.keys(config).map((key) => (
            <Grid item xs={12} sm={6} key={key}>
              <TextField
                label={configDescriptions[key]}
                type="number"
                value={config[key] === undefined ? '' : config[key]}
                onChange={(e) => handleChange(key, e.target.value)}
                fullWidth
                margin="normal"
                InputProps={{
                  step: key.includes('PERCENT') ? '0.01' : '1', // Step for percentages vs whole numbers
                }}
                error={!!validateField(key, config[key])} // Show error immediately
                helperText={validateField(key, config[key])}
              />
            </Grid>
          ))}
        </Grid>
        <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 4 }}>
          <Button
            type="submit"
            variant="contained"
            color="primary"
            disabled={isSubmitting}
            sx={{ borderRadius: 2 }}
          >
            {isSubmitting ? <CircularProgress size={24} color="inherit" /> : t('save_button')}
          </Button>
        </Box>
      </Box>
    </Paper>
  );
};

export default AppConfigForm;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/LoginPageClient.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useState } from 'react';
import { Box, TextField, Button, Typography, CircularProgress, Alert } from '@mui/material';
import { useTranslations } from 'next-intl';
import { signIn } from 'next-auth/react';
import { useRouter } from 'next/navigation';

const LoginPageClient: React.FC = () => {
  const t = useTranslations('login');
  const tGeneral = useTranslations();

  // Change state variable from 'email' to 'username'
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleLogin = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setLoading(true);
    setError(null);

    const result = await signIn('credentials', {
      redirect: false,
      username, // Pass the 'username' state here
      password,
    });

    setLoading(false);

    if (result?.error) {
      setError(tGeneral('auth.login_failed'));
      console.error("Login failed:", result.error);
    } else {
      router.push('/en/dashboard'); // Or dynamically determine locale
    }
  };

  return (
    <Box
      component="form"
      onSubmit={handleLogin}
      sx={{
        marginTop: 8,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        maxWidth: 400,
        margin: '0 auto',
        padding: 3,
        border: '1px solid #ccc',
        borderRadius: 2,
        boxShadow: 3
      }}
    >
      <Typography component="h1" variant="h5" gutterBottom>
        {t('title')}
      </Typography>
      {error && (
        <Alert severity="error" sx={{ marginBottom: 2, width: '100%' }}>
          {error}
        </Alert>
      )}
      <TextField
        margin="normal"
        required
        fullWidth
        id="username" // Change ID from 'email' to 'username'
        label={t('username_label')} // Use new translation key for label
        name="username"
        autoComplete="username" // Change autoComplete
        autoFocus
        value={username}
        onChange={(e) => setUsername(e.target.value)} // Update state setter
      />
      <TextField
        margin="normal"
        required
        fullWidth
        name="password"
        label={t('password_label')}
        type="password"
        id="password"
        autoComplete="current-password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      <Button
        type="submit"
        fullWidth
        variant="contained"
        sx={{ marginTop: 3, marginBottom: 2 }}
        disabled={loading}
      >
        {loading ? <CircularProgress size={24} color="inherit" /> : t('login_button')}
      </Button>
    </Box>
  );
};

export default LoginPageClient;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/LoginForm.tsx
TYPE: typescript-react
CONTENT:
```
// src/components/LoginForm.tsx
"use client"; // This directive MUST be the very first line

import React, { useState } from 'react';
import { signIn } from 'next-auth/react'; // signIn is a client-side function
import { useRouter, useParams } from 'next/navigation'; // useRouter and useParams are client-side hooks
import Box from '@mui/material/Box';
import TextField from '@mui/material/TextField';
import Button from '@mui/material/Button';
import Typography from '@mui/material/Typography';
import CircularProgress from '@mui/material/CircularProgress';
import Alert from '@mui/material/Alert';
import { useTranslations } from 'next-intl'; // useTranslations can be used in Client Components


const LoginForm: React.FC = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const router = useRouter();
  const params = useParams();
  const locale = params.locale as string; // Access locale from params in Client Component

  const t = useTranslations('login'); // Use translations in Client Component

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setError(null);
    setLoading(true);

    const result = await signIn('credentials', {
      redirect: false, // Prevent automatic redirect
      username,
      password,
    });

    setLoading(false);

    if (result?.error) {
      console.error("Login failed:", result.error);
      // Use translation for login error message
      setError(t('login_error'));
    } else {
      // Redirect to the dashboard page for the current locale
      router.push(`/${locale}/dashboard`);
    }
  };

  return (
    <Box
      component="form"
      onSubmit={handleSubmit}
      sx={{
        mt: 3,
        p: 3,
        border: '1px solid #ccc',
        borderRadius: '8px',
        maxWidth: 400,
        width: '100%',
        display: 'flex',
        flexDirection: 'column',
        gap: 2,
      }}
    >
      {error && <Alert severity="error">{error}</Alert>}
      <TextField
        label={t('username_label')}
        variant="outlined"
        fullWidth
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        required
      />
      <TextField
        label={t('password_label')}
        variant="outlined"
        fullWidth
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        required
      />
      <Button type="submit" variant="contained" color="primary" fullWidth disabled={loading}>
        {loading ? <CircularProgress size={24} /> : t('login_button')}
      </Button>
    </Box>
  );
};

export default LoginForm;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/BillList.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useState } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Box,
  IconButton,
  useMediaQuery,
  useTheme,
  List,
  ListItem,
  ListItemText,
  Grid,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  Button,
  CircularProgress,
  Alert,
} from '@mui/material';
import { Edit as EditIcon, Delete as DeleteIcon, CheckCircle, Close } from '@mui/icons-material';
import { useTranslations } from 'next-intl';
import { Bill } from '@/types/Bill';
import { format, parseISO } from 'date-fns';

interface BillListProps {
  bills: Bill[];
  onEdit: (billId: string) => void;
  onDelete: (billId: number) => void;
  showDateColumn?: boolean;
}

const BillList: React.FC<BillListProps> = ({ bills, onEdit, onDelete, showDateColumn = true }) => {
  const t = useTranslations('bill_list');
  const tMealType = useTranslations('meal_type');
  const tEdit = useTranslations('edit');
  const tErrors = useTranslations('errors');
  const tGeneral = useTranslations('general');

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const [openDeleteConfirm, setOpenDeleteConfirm] = useState(false);
  const [billToDeleteId, setBillToDeleteId] = useState<number | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [deleteError, setDeleteError] = useState<string | null>(null);

  const formatCurrency = (amount: number | string) => {
    let numericAmount: number;
    if (typeof amount === 'string') {
      const cleanedString = amount.replace(/[¥,]/g, '');
      numericAmount = Number(cleanedString);
    } else {
      numericAmount = amount;
    }
    if (isNaN(numericAmount)) {
      numericAmount = 0;
    }
    return `¥${numericAmount.toLocaleString()}`;
  };

  const handleDeleteClick = (billId: number) => {
    onDelete(billId);
  };

  if (!bills || bills.length === 0) {
    return (
      <Paper elevation={2} sx={{ p: 2, mb: 2, textAlign: 'center', borderRadius: 2 }}>
        <Typography variant="body1">{tErrors('bill_not_found')}</Typography>
      </Paper>
    );
  }

  return (
    <Box sx={{ width: '100%' }}>
      {isMobile ? (
        <List sx={{ width: '100%', bgcolor: 'background.paper', p: 0 }}>
          {bills.map((bill) => (
            <Paper key={bill.id} elevation={2} sx={{ mb: 2, p: 2, borderRadius: 2 }}>
              {showDateColumn && (
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body2" color="text.secondary">{t('date')}:</Typography>
                  <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium' }}>
                    {format(parseISO(bill.date), 'yyyy-MM-dd')}
                  </Typography>
                </Box>
              )}
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('meal_type')}:</Typography>
                <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium' }}>
                  {tMealType(bill.mealType)}
                </Typography>
              </Box>

              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('food_amount')}:</Typography>
                <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium' }}>
                  {formatCurrency(bill.foodAmount)}
                </Typography>
              </Box>

              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('drink_amount')}:</Typography>
                <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium' }}>
                  {formatCurrency(bill.drinkAmount)}
                </Typography>
              </Box>

              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('is_our_food')}:</Typography>
                {bill.isOurFood ? (
                  <CheckCircle color="success" fontSize="small" />
                ) : (
                  <Close color="error" fontSize="small" />
                )}
              </Box>

              {bill.mealType === 'dinner' && (
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body2" color="text.secondary">{t('num_people_working')}:</Typography>
                  <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium' }}>
                    {bill.numberOfPeopleWorkingDinner || '-'}
                  </Typography>
                </Box>
              )}

              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('comments')}:</Typography>
                <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium', textAlign: 'right', flexGrow: 1, ml: 1 }}>
                  {bill.comments || '-'}
                </Typography>
              </Box>
              
              <Box sx={{ display: 'flex', justifyContent: 'flex-end', pt: 2, borderTop: '1px solid', borderColor: 'divider', mt: 1 }}>
                <IconButton onClick={() => onEdit(bill.id.toString())} color="primary" aria-label={t('edit')}>
                  <EditIcon />
                </IconButton>
                <IconButton onClick={() => handleDeleteClick(parseInt(bill.id))} color="error" aria-label={t('delete')}>
                  <DeleteIcon />
                </IconButton>
              </Box>
            </Paper>
          ))}
        </List>
      ) : (
        <TableContainer component={Paper} elevation={3} sx={{ borderRadius: 3 }}>
          <Table sx={{ minWidth: 650 }} aria-label="bill list">
            <TableHead>
              <TableRow>
                {showDateColumn && <TableCell>{t('date')}</TableCell>}
                <TableCell>{t('meal_type')}</TableCell>
                <TableCell align="right">{t('food_amount')}</TableCell>
                <TableCell align="right">{t('drink_amount')}</TableCell>
                <TableCell align="center">{t('is_our_food')}</TableCell>
                <TableCell align="right">{t('num_people_working')}</TableCell>
                <TableCell>{t('comments')}</TableCell>
                <TableCell align="center">{t('actions')}</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {bills.map((bill) => (
                <TableRow key={bill.id}>
                  {showDateColumn && (
                    <TableCell component="th" scope="row">
                      {format(parseISO(bill.date), 'yyyy-MM-dd')}
                    </TableCell>
                  )}
                  <TableCell>{tMealType(bill.mealType)}</TableCell>
                  <TableCell align="right">{formatCurrency(bill.foodAmount)}</TableCell>
                  <TableCell align="right">{formatCurrency(bill.drinkAmount)}</TableCell>
                  <TableCell align="center">
                    {bill.isOurFood ? (
                      <CheckCircle color="success" />
                    ) : (
                      <Close color="error" />
                    )}
                  </TableCell>
                  <TableCell align="right">
                    {bill.mealType === 'dinner' ? (bill.numberOfPeopleWorkingDinner || '-') : '-'}
                  </TableCell>
                  <TableCell sx={{ maxWidth: 200, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                    {bill.comments || '-'}
                  </TableCell>
                  <TableCell align="center">
                    <IconButton onClick={() => onEdit(bill.id.toString())} color="primary" aria-label={t('edit')}>
                      <EditIcon />
                    </IconButton>
                    <IconButton onClick={() => handleDeleteClick(parseInt(bill.id))} color="error" aria-label={t('delete')}>
                      <DeleteIcon />
                    </IconButton>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}
    </Box>
  );
};

export default BillList;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/PurchaseBillForm.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useState, useEffect, useCallback, useMemo } from 'react'; // Added useCallback
import {
  TextField,
  Button,
  Box,
  CircularProgress,
  Alert,
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format, parseISO, isValid } from 'date-fns';
import { useTranslations } from 'next-intl';
import { useRouter } from 'next/navigation';
import { enUS, ja } from 'date-fns/locale';

interface PurchaseBill {
  id?: string;
  date: string;
  amount: number;
  description: string;
  comments?: string | null;
}

interface PurchaseBillFormProps {
  initialPurchaseBill?: PurchaseBill;
  onSubmit: (data: Omit<PurchaseBill, 'id'>, currentBillId?: string) => void;
  isSubmitting?: boolean;
  defaultDate?: Date;
  onCancel: () => void;
}

const PurchaseBillForm: React.FC<PurchaseBillFormProps> = ({
  initialPurchaseBill,
  onSubmit,
  isSubmitting,
  defaultDate,
  onCancel,
}) => {
  const t = useTranslations('purchase_bill_form');
  const tErrors = useTranslations('errors');
  const tGeneral = useTranslations('general');

  const router = useRouter();
  const locale = router.locale as string;

  const [date, setDate] = useState<Date | null>(
    initialPurchaseBill?.date ? parseISO(initialPurchaseBill.date) : (defaultDate || new Date())
  );
  const [amount, setAmount] = useState<number | ''>(initialPurchaseBill?.amount ?? 0);
  const [description, setDescription] = useState<string>(initialPurchaseBill?.description ?? '');
  const [comments, setComments] = useState<string>(initialPurchaseBill?.comments ?? '');

  const [errors, setErrors] = useState<{ [key: string]: string }>({});
  const [formError, setFormError] = useState<string | null>(null);

  const dateFnsLocale = useMemo(() => {
    return locale === 'ja' ? ja : enUS;
  }, [locale]);

  useEffect(() => {
    if (initialPurchaseBill) {
      setDate(parseISO(initialPurchaseBill.date));
      setAmount(initialPurchaseBill.amount);
      setDescription(initialPurchaseBill.description);
      setComments(initialPurchaseBill.comments ?? '');
    } else if (defaultDate) {
      setDate(defaultDate);
      setAmount(0);
      setDescription('');
      setComments('');
    }
    setFormError(null);
    setErrors({});
  }, [initialPurchaseBill, defaultDate]);

  const validateForm = useCallback(() => { // Using useCallback
    const newErrors: { [key: string]: string } = {};

    if (!date || !isValid(date)) {
      newErrors.date = tErrors('invalid_date');
    }

    if (amount === '' || amount < 0) {
      newErrors.amount = tErrors('positive_number');
    }

    if (!description.trim()) {
      newErrors.description = tErrors('required');
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [date, amount, description, tErrors]);

  const handleSubmit = useCallback(async (e: React.FormEvent) => { // Using useCallback
    e.preventDefault();

    if (!validateForm()) {
      setFormError(tGeneral('errors.form_validation_failed') || 'Please correct the errors in the form.');
      return;
    }
    setFormError(null);

    const formattedDate = date ? format(date, 'yyyy-MM-dd') : '';

    const formData: Omit<PurchaseBill, 'id'> = {
      date: formattedDate,
      amount: Number(amount),
      description: description.trim(),
      comments: comments.trim() || null,
    };

    onSubmit(formData, initialPurchaseBill?.id);
  }, [date, amount, description, comments, onSubmit, initialPurchaseBill, validateForm, tGeneral]);

  return (
    <Box component="form" onSubmit={handleSubmit} noValidate sx={{ mt: 1 }}>
      {formError && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {formError}
        </Alert>
      )}

      <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={dateFnsLocale}>
        <DatePicker
          label={t('date_label')}
          value={date}
          onChange={(newDate) => setDate(newDate)}
          slotProps={{ textField: { fullWidth: true, margin: "normal", error: !!errors.date, helperText: errors.date } }}
          format="yyyy-MM-dd"
        />
      </LocalizationProvider>

      <TextField
        label={t('amount_label')}
        value={amount}
        onChange={(e) => setAmount(e.target.value === '' ? '' : Number(e.target.value))}
        fullWidth
        margin="normal"
        type="number"
        inputProps={{ min: 0 }}
        error={!!errors.amount}
        helperText={errors.amount}
      />

      <TextField
        label={t('description_label')}
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        fullWidth
        margin="normal"
        error={!!errors.description}
        helperText={errors.description}
      />

      <TextField
        label={t('comments_label')}
        value={comments}
        onChange={(e) => setComments(e.target.value)}
        fullWidth
        multiline
        rows={4}
        margin="normal"
        sx={{
          '& .MuiInputLabel-root': {
            transform: 'translate(14px, 14px) scale(1)',
          },
          '& .MuiInputLabel-shrink': {
            transform: 'translate(14px, -9px) scale(0.75)',
          },
          '& .MuiOutlinedInput-root': {
            paddingTop: '18px',
          },
        }}
      />

      <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 2 }}>
        <Button onClick={onCancel} sx={{ mr: 2 }} disabled={isSubmitting}>
          {tGeneral('cancel')}
        </Button>
        <Button type="submit" variant="contained" color="primary" disabled={isSubmitting}>
          {isSubmitting ? <CircularProgress size={24} /> : tGeneral('save')}
        </Button>
      </Box>
    </Box>
  );
};

export default PurchaseBillForm;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/DateRangeFilter.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useEffect, useState } from 'react'; // Import useEffect and useState
import { Box, TextField, Grid, Typography, Alert } from '@mui/material'; // Removed Button
import { useTranslations } from 'next-intl';
import { format, isValid, parseISO, isAfter } from 'date-fns';

export interface DateRangeFilterProps {
  onApplyFilter: (fromDate: string, toDate: string) => void; // Only onApplyFilter
  fromDate: string;
  toDate: string;
}

export const DateRangeFilter: React.FC<DateRangeFilterProps> = ({
  onApplyFilter,
  fromDate,
  toDate
}) => {
  const t = useTranslations('date_range_filter');
  const tSummary = useTranslations('summary');
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  // Internal state for the text fields, so validation can happen on change
  const [internalFromDate, setInternalFromDate] = useState(fromDate);
  const [internalToDate, setInternalToDate] = useState(toDate);

  // Keep internal state in sync with external props
  useEffect(() => {
    setInternalFromDate(fromDate);
    setInternalToDate(toDate);
  }, [fromDate, toDate]);

  // Effect to apply filter whenever internalFromDate or internalToDate changes
  useEffect(() => {
    setErrorMessage(null); // Clear previous errors

    // Only attempt to apply if both dates are selected
    if (!internalFromDate || !internalToDate) {
        // setErrorMessage(t('dates_not_selected')); // Optionally show this error if not selected
        return; // Don't apply filter if dates are not fully selected
    }

    const parsedFromDate = parseISO(internalFromDate);
    const parsedToDate = parseISO(internalToDate);

    if (!isValid(parsedFromDate) || !isValid(parsedToDate)) {
      setErrorMessage(t('invalid_date_format'));
      return;
    }

    if (isAfter(parsedFromDate, parsedToDate)) {
      setErrorMessage(t('from_date_after_to_date'));
      return;
    }

    // If validation passes, immediately apply filter
    onApplyFilter(internalFromDate, internalToDate);
  }, [internalFromDate, internalToDate, onApplyFilter, t]); // Add t as dependency

  return (
    <Box sx={{ mb: 3 }}>
      <Typography variant="h6" gutterBottom>{tSummary('filter_title')}</Typography>
      {errorMessage && <Alert severity="error" sx={{ mb: 2 }}>{errorMessage}</Alert>}
      <Grid
        container
        spacing={2}
        alignItems="center"
      >
        <Grid item xs={12} sm={6}> {/* Allocate space for From Date */}
          <TextField
            label={t('from_date')}
            type="date"
            value={internalFromDate}
            onChange={(e) => setInternalFromDate(e.target.value)} // Update internal state
            fullWidth
            InputLabelProps={{
              shrink: true,
            }}
          />
        </Grid>
        <Grid item xs={12} sm={6}> {/* Allocate space for To Date */}
          <TextField
            label={t('to_date')}
            type="date"
            value={internalToDate}
            onChange={(e) => setInternalToDate(e.target.value)} // Update internal state
            fullWidth
            InputLabelProps={{
              shrink: true,
            }}
          />
        </Grid>
      </Grid>
    </Box>
  );
};

export default DateRangeFilter;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/ThemeProviderWrapper.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useState, useMemo, useEffect, createContext, useContext, useCallback } from 'react'; // Added useCallback here
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { lightTheme, darkTheme } from '@/theme';

interface ThemeContextType {
  toggleTheme: () => void;
  mode: 'light' | 'dark';
}

export const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

interface ThemeProviderWrapperProps {
  children: React.ReactNode;
}

const ThemeProviderWrapper: React.FC<ThemeProviderWrapperProps> = ({ children }) => {
  const [mode, setMode] = useState<'light' | 'dark'>('light');

  useEffect(() => {
    const savedMode = localStorage.getItem('themeMode') as 'light' | 'dark';
    if (savedMode) {
      setMode(savedMode);
    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      setMode('dark');
    }
  }, []);

  const theme = useMemo(() => (mode === 'light' ? lightTheme : darkTheme), [mode]);

  const toggleTheme = useCallback(() => {
    setMode((prevMode) => {
      const newMode = prevMode === 'light' ? 'dark' : 'light';
      localStorage.setItem('themeMode', newMode);
      return newMode;
    });
  }, []);

  const themeContextValue = useMemo(() => ({ toggleTheme, mode }), [toggleTheme, mode]);

  return (
    <ThemeContext.Provider value={themeContextValue}>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        {children}
      </ThemeProvider>
    </ThemeContext.Provider>
  );
};

export default ThemeProviderWrapper;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/NextIntlClientProviderWrapper.tsx
TYPE: typescript-react
CONTENT:
```
// src/components/NextIntlClientProviderWrapper.tsx
"use client";

import { NextIntlClientProvider } from "next-intl";
import { AbstractIntlMessages } from "next-intl";

interface NextIntlClientProviderWrapperProps {
  children: React.ReactNode;
  messages: AbstractIntlMessages;
  timeZone: string;
  locale: string; // CRITICAL FIX: Add locale to props
}

const NextIntlClientProviderWrapper: React.FC<NextIntlClientProviderWrapperProps> = ({
  children,
  messages,
  timeZone,
  locale, // CRITICAL FIX: Destructure locale
}) => {
  return (
    // CRITICAL FIX: Pass locale to NextIntlClientProvider
    <NextIntlClientProvider messages={messages} timeZone={timeZone} locale={locale}>
      {children}
    </NextIntlClientProvider>
  );
};

export default NextIntlClientProviderWrapper;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/SummaryPageClient.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react'; // Added useRef
import { useTranslations } from 'next-intl';
import {
  Container,
  Typography,
  Box,
  CircularProgress,
  Alert,
  Grid,
  Button,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Card,
  CardContent,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { format, parseISO, isValid, addDays } from 'date-fns';
import { enUS, ja } from 'date-fns/locale';

import { useRouter, usePathname } from 'next/navigation';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
} from 'recharts';
import DailyBillSummary from './DailyBillSummary'; // Correctly importing DailyBillSummary
import { calculateDailySummariesForRange, DailySummary } from '@/lib/calculations';

// Define the Bill type to match what's passed from summary/page.tsx and calculations.ts expects
interface Bill {
  id: string;
  date: string; // ISO string 'yyyy-MM-dd'
  foodAmount: number; // Now explicitly foodAmount
  drinkAmount: number; // Now explicitly drinkAmount
  mealType: 'lunch' | 'dinner';
  isOurFood: boolean;
  numberOfPeopleWorkingDinner: number;
  comments?: string | null;
}

interface SummaryPageClientProps {
  locale: string;
  initialBills: Bill[];
  initialFromDate?: string;
  initialToDate?: string;
  initialError?: string | null;
}

// Define colors for the pie chart
const PIE_COLORS = ['#8884d8', '#82ca9d', '#ffc658', '#ff7300'];

const SummaryPageClient: React.FC<SummaryPageClientProps> = ({
  locale,
  initialBills,
  initialFromDate,
  initialToDate,
  initialError,
}) => {
  const t = useTranslations('summary');
  const tGeneral = useTranslations('general');
  const tMealType = useTranslations('meal_type');

  const router = useRouter();
  const pathname = usePathname();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const [bills, setBills] = useState<Bill[]>(initialBills);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(initialError);

  const [fromDate, setFromDate] = useState<Date | null>(
    initialFromDate ? parseISO(initialFromDate) : null
  );
  const [toDate, setToDate] = useState<Date | null>(
    initialToDate ? parseISO(initialToDate) : null
  );
  
  const [selectedDailySummaryEntry, setSelectedDailySummaryEntry] = useState<{ date: string; summary: DailySummary } | null>(null);

  // Ref for the DailyBillSummary section
  const dailyBillSummaryRef = useRef<HTMLDivElement>(null);

  const dateFnsLocale = useMemo(() => {
    return locale === 'ja' ? ja : enUS;
  }, [locale]);

  const dailySummariesForRange = useMemo(() => {
    const calculatedSummaries = calculateDailySummariesForRange(bills);
    return calculatedSummaries;
  }, [bills]);

  useEffect(() => {
    setBills(initialBills);
    setError(initialError);
    setFromDate(initialFromDate && isValid(parseISO(initialFromDate)) ? parseISO(initialFromDate) : null);
    setToDate(initialToDate && isValid(parseISO(initialToDate)) ? parseISO(initialToDate) : null);
    setSelectedDailySummaryEntry(null); 
  }, [initialBills, initialError, initialFromDate, initialToDate]);

  const fetchBills = useCallback(async () => {
    setLoading(true);
    setError(null);

    let fromDateStr = fromDate && isValid(fromDate) ? format(fromDate, 'yyyy-MM-dd') : '';
    let toDateStr = toDate && isValid(toDate) ? format(toDate, 'yyyy-MM-dd') : '';

    if (!fromDate || !isValid(fromDate) || !toDate || !isValid(toDate)) {
      setError(t('errors.invalid_date_range') || 'Invalid date range selected.');
      setLoading(false);
      return;
    }
    if (fromDate > toDate) {
      setError(t('errors.date_range_order') || 'From date cannot be after To date.');
      setLoading(false);
      return;
    }

    const queryParams = new URLSearchParams();
    queryParams.append('from', fromDateStr);
    queryParams.append('to', toDateStr);

    const apiUrl = `/api/reports?${queryParams.toString()}`;

    try {
      const response = await fetch(apiUrl);
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to fetch bills');
      }
      const data: Bill[] = await response.json();
      setBills(data);
    } catch (err: any) {
      console.error('SummaryPageClient: Error fetching bills (client-side):', err);
      setError(err.message || 'An unexpected error occurred.');
    } finally {
      setLoading(false);
    }
  }, [fromDate, toDate, t]);

  const handleApplyFilter = useCallback(() => {
    const currentPath = pathname.replace(`/${locale}`, '');
    const query = new URLSearchParams();
    if (fromDate && isValid(fromDate)) {
      query.append('from', format(fromDate, 'yyyy-MM-dd'));
    }
    if (toDate && isValid(toDate)) {
      query.append('to', format(toDate, 'yyyy-MM-dd'));
    }
    
    router.push(`/${locale}${currentPath}?${query.toString()}`);
  }, [fromDate, toDate, pathname, router, locale]);

  const handleBarClick = useCallback((data: { date: string; fullDate: string; earnings: number }) => {
    const clickedFullDate = data.fullDate;
    const foundSummary = dailySummariesForRange.find(entry => entry.date === clickedFullDate);
    if (foundSummary) {
      setSelectedDailySummaryEntry(foundSummary);
      // Scroll to the DailyBillSummary component on mobile
      if (isMobile && dailyBillSummaryRef.current) {
        dailyBillSummaryRef.current.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    } else {
      setSelectedDailySummaryEntry(null);
      console.error('No daily summary found for clicked date:', clickedFullDate);
    }
  }, [dailySummariesForRange, isMobile]); // Added isMobile to dependencies

  const dailyEarningsData = useMemo(() => {
    const chartData = dailySummariesForRange
      .map(entry => {
        const parsedDate = parseISO(entry.date);
        if (!isValid(parsedDate)) {
          console.error('SummaryPageClient: Invalid date encountered:', entry.date);
        }
        const formattedDate = isValid(parsedDate) ? format(parsedDate, 'MMM dd', { locale: dateFnsLocale }) : 'Invalid Date';
        return {
          date: formattedDate,
          fullDate: entry.date,
          earnings: entry.summary.dayTotalEarnings,
        };
      })
      .sort((a, b) => a.fullDate.localeCompare(b.fullDate));
    return chartData;
  }, [dailySummariesForRange, dateFnsLocale]);

  const mealTypeDistributionData = useMemo(() => {
    const mealTypeMap: { [key: string]: number } = {
      lunch: 0,
      dinner: 0,
    };
    bills.forEach(bill => {
      mealTypeMap[bill.mealType] += (bill.foodAmount + bill.drinkAmount);
    });

    const data = [];
    if (mealTypeMap.lunch > 0) {
      data.push({ name: tMealType('lunch'), value: mealTypeMap.lunch });
    }
    if (mealTypeMap.dinner > 0) {
      data.push({ name: tMealType('dinner'), value: mealTypeMap.dinner });
    }
    return data;
  }, [bills, tMealType]);

  const totalEarnings = useMemo(() => {
    return dailySummariesForRange.reduce((sum, entry) => sum + entry.summary.dayTotalEarnings, 0);
  }, [dailySummariesForRange]);

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        {t('summary_title')}
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      {/* Filter controls */}
      <Grid container spacing={3} alignItems="center" sx={{ mb: 4 }}>
        <Grid sx={{ gridColumn: { xs: 'span 12', sm: 'span 6', md: 'span 3' } }}>
          <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={dateFnsLocale}>
            <DatePicker
              label={t('from_date')}
              value={fromDate}
              onChange={(newValue) => setFromDate(newValue)}
              slotProps={{ textField: { fullWidth: true, variant: 'outlined', size: 'small', sx: { borderRadius: 2 } } }}
            />
          </LocalizationProvider>
        </Grid>
        <Grid sx={{ gridColumn: { xs: 'span 12', sm: 'span 6', md: 'span 3' } }}>
          <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={dateFnsLocale}>
            <DatePicker
              label={t('to_date')}
              value={toDate}
              onChange={(newValue) => setToDate(newValue)}
              slotProps={{ textField: { fullWidth: true, variant: 'outlined', size: 'small', sx: { borderRadius: 2 } } }}
            />
          </LocalizationProvider>
        </Grid>
        <Grid sx={{ gridColumn: { xs: 'span 12', sm: 'span 6', md: 'span 3' } }}>
          <Button
            variant="contained"
            color="primary"
            onClick={handleApplyFilter}
            disabled={loading}
            fullWidth
            sx={{ height: '40px', borderRadius: 2 }}
          >
            {loading ? <CircularProgress size={24} color="inherit" /> : t('apply_filter')}
          </Button>
        </Grid>
      </Grid>

      {/* Total Earnings Card */}
      <Card sx={{ mb: 4, borderRadius: 3, boxShadow: 3 }}>
        <CardContent>
          <Typography variant="h5" component="h2" gutterBottom>
            {t('total_earnings')}
          </Typography>
          <Typography variant="h4" color="primary">
            ¥{totalEarnings.toLocaleString(locale)}
          </Typography>
        </CardContent>
      </Card>

      {/* Charts Grid Container */}
      <Grid container spacing={4} sx={{ display: 'grid', gridTemplateColumns: { xs: 'repeat(1, 1fr)', md: 'repeat(2, 1fr)' }, gap: theme.spacing(4) }}>
        {/* Bar Chart Grid Item */}
        <Grid sx={{
          gridColumn: { xs: 'span 1', md: 'span 1' },
          display: 'flex',
          flexDirection: 'column',
          minWidth: 0,
          height: '400px',
        }}>
          <Card
            sx={{
              borderRadius: 3,
              boxShadow: 3,
              width: '100%',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
            }}
          >
            <CardContent sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
              <Typography variant="h6" gutterBottom>{t('daily_earnings_chart')}</Typography>
              <Box sx={{ flexGrow: 1, width: '100%', height: '100%' }}>
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart
                    data={dailyEarningsData}
                    margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="date" style={{ fontSize: '0.75rem' }} />
                    <YAxis tickFormatter={(value) => `¥${value.toLocaleString(locale)}`} style={{ fontSize: '0.75rem' }} />
                    <Tooltip formatter={(value: number) => `¥${value.toLocaleString(locale)}`} />
                    <Legend />
                    <Bar
                      dataKey="earnings"
                      name={t('earnings')}
                      fill="#8884d8"
                      radius={[10, 10, 0, 0]}
                      onClick={handleBarClick}
                      cursor="pointer"
                    />
                  </BarChart>
                </ResponsiveContainer>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        {/* Pie Chart Grid Item */}
        <Grid sx={{
          gridColumn: { xs: 'span 1', md: 'span 1' },
          display: 'flex',
          flexDirection: 'column',
          minWidth: 0,
          height: '400px',
        }}>
          <Card
            sx={{
              borderRadius: 3,
              boxShadow: 3,
              width: '100%',
              height: '100%',
              display: 'flex',
              flexDirection: 'column',
            }}
          >
            <CardContent sx={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
              <Typography variant="h6" gutterBottom>{t('meal_type_distribution_chart')}</Typography>
              <Box sx={{ flexGrow: 1, width: '100%', height: '100%' }}>
                <ResponsiveContainer width="100%" height="100%">
                  <PieChart>
                    <Pie
                      data={mealTypeDistributionData}
                      cx="50%"
                      cy="50%"
                      outerRadius={isMobile ? 80 : 120}
                      fill="#8884d8"
                      dataKey="value"
                      label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                      activeShape={false}
                    >
                      {mealTypeDistributionData.map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={PIE_COLORS[index % PIE_COLORS.length]} />
                      ))}
                    </Pie>
                    <Tooltip formatter={(value: number) => `¥${value.toLocaleString(locale)}`} />
                    <Legend />
                  </PieChart>
                </ResponsiveContainer>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* DailyBillSummary Section - Attach ref here */}
      {selectedDailySummaryEntry && (
        <Box ref={dailyBillSummaryRef} sx={{ mt: 4 }}> {/* Attach the ref */}
          <DailyBillSummary
            date={selectedDailySummaryEntry.date}
            dailySummary={selectedDailySummaryEntry.summary}
            locale={locale}
            onClose={() => setSelectedDailySummaryEntry(null)}
          />
        </Box>
      )}

      {/* No bills found message */}
      {!loading && !bills.length && (
        <Typography sx={{ mt: 2 }}>
          {t('no_bills_found')}
        </Typography>
      )}
    </Container>
  );
};

export default SummaryPageClient;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/DashboardPageClient.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import { useSession } from 'next-auth/react';
import { useRouter, useParams, usePathname } from 'next/navigation';
import React, { useEffect, useState, useMemo, useCallback } from 'react';
import BillForm from '@/components/BillForm';
import DailySummaryCard from '@/components/DailySummaryCard';
import BillList from '@/components/BillList';
import Box from '@mui/material/Box';
import Typography from '@mui/material/Typography';
import CircularProgress from '@mui/material/CircularProgress';
import Alert from '@mui/material/Alert';
import Button from '@mui/material/Button';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import IconButton from '@mui/material/IconButton';
import ArrowBackIosIcon from '@mui/icons-material/ArrowBackIos';
import ArrowForwardIosIcon from '@mui/icons-material/ArrowForwardIos';
import CloseIcon from '@mui/icons-material/Close';
import { useTheme, useMediaQuery } from '@mui/material';

import { format, addDays, subDays } from 'date-fns';
import { enUS, ja } from 'date-fns/locale';
import { useTranslations } from 'next-intl';

import { Bill } from '@/types/Bill'; // Ensure this type is correct and accessible
import { calculateDailyEarnings } from '@/lib/calculations'; // Ensure this import path is correct

const DashboardPageClient: React.FC = () => {
  const { data: session, status } = useSession();
  const router = useRouter();
  const params = useParams();
  const locale = params.locale as string;
  const pathname = usePathname();

  const [currentDate, setCurrentDate] = useState(new Date());

  const dateFnsLocale = useMemo(() => {
    return locale === 'ja' ? ja : enUS;
  }, [locale]);

  const formattedCurrentDate = format(currentDate, 'yyyy-MM-dd', { locale: dateFnsLocale });

  const [billsForDate, setBillsForDate] = useState<Bill[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingBillId, setEditingBillId] = useState<string | undefined>(undefined);
  const [initialBillData, setInitialBillData] = useState<Bill | undefined>(undefined);
  const [isModalLoading, setIsModalLoading] = useState(false);

  const [openConfirmDelete, setOpenConfirmDelete] = useState(false);
  const [billToDeleteId, setBillToDeleteId] = useState<number | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [deleteError, setDeleteError] = useState<string | null>(null);

  const t = useTranslations('dashboard');
  const tGeneral = useTranslations();
  const tBillForm = useTranslations('bill_form');

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  // This is where the summary is calculated from the fetched bills
  const dailySummary = useMemo(() => {
    return calculateDailyEarnings(billsForDate);
  }, [billsForDate]);

  const fetchBillsForDate = useCallback(async (dateToFetch: Date) => {
    if (status !== 'authenticated') {
      return;
    }

    setLoading(true);
    setError(null);

    const formattedDateToFetch = format(dateToFetch, 'yyyy-MM-dd');

    try {
      // Ensure the API endpoint is correct and returns the expected Bill structure
      const res = await fetch(`/${locale}/api/reports?from=${formattedDateToFetch}&to=${formattedDateToFetch}`);
      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || tGeneral('errors.failed_fetch'));
      }
      const data = await res.json();

      // IMPORTANT: Ensure data.bills is an array and its elements match the Bill type
      const processedBills: Bill[] = data.bills.map((bill: any) => ({
        ...bill,
        // Ensure date is a string in 'yyyy-MM-dd' format
        date: format(new Date(bill.date), 'yyyy-MM-dd'),
        // Ensure mealType is correctly typed as 'lunch' or 'dinner'
        mealType: bill.mealType.toString().toLowerCase() as 'lunch' | 'dinner',
        // Provide defaults for optional fields if they might be null/undefined from API
        isOurFood: bill.isOurFood ?? true, // Default to true if not provided
        numberOfPeopleWorkingDinner: bill.numberOfPeopleWorkingDinner ?? 1, // Default to 1 if not provided
        comments: bill.comments ?? null,
      }));
      setBillsForDate(processedBills);

    } catch (err: any) {
      console.error("Error fetching bills for date:", err); // Log the error for debugging
      setError(err.message || tGeneral('errors.failed_fetch'));
      setBillsForDate([]); // Ensure bills are cleared on error
    } finally {
      setLoading(false);
    }
  }, [status, locale, tGeneral]);

  useEffect(() => {
    if (status === 'loading') return;
    if (
      status === 'unauthenticated' &&
      pathname !== `/${locale}`
    ) {
      router.push(`/${locale}`);
    }
  }, [status, router, locale, pathname]);

  useEffect(() => {
    if (status === 'authenticated') {
      fetchBillsForDate(currentDate);
    }
  }, [status, locale, currentDate, fetchBillsForDate]);

  const handleCloseModal = useCallback(() => {
    setIsModalOpen(false);
    setEditingBillId(undefined);
    setInitialBillData(undefined);
    setError(null);
  }, []);

  const handleOpenAddModal = useCallback(() => {
    setEditingBillId(undefined);
    setInitialBillData(undefined);
    setIsModalOpen(true);
    setIsModalLoading(false);
  }, []);

  const handleOpenEditModal = useCallback(async (billId: string) => {
    setEditingBillId(billId);
    setInitialBillData(undefined);
    setIsModalOpen(true);
    setIsModalLoading(true);

    try {
      const response = await fetch(`/${locale}/api/bills/${billId}`);
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || `Error: ${response.status}`);
      }
      const data: Bill = await response.json();
      const formattedData = {
        ...data,
        date: format(new Date(data.date), 'yyyy-MM-dd'),
        mealType: data.mealType.toString().toLowerCase() as 'lunch' | 'dinner',
        isOurFood: data.isOurFood ?? true,
        numberOfPeopleWorkingDinner: data.numberOfPeopleWorkingDinner ?? 1,
        comments: data.comments ?? null,
      };
      setInitialBillData(formattedData);
    } catch (err: any) {
      console.error("Error fetching bill for edit:", err); // Log the error
      setError(err.message || tGeneral('errors.failed_fetch'));
      handleCloseModal();
    } finally {
      setIsModalLoading(false);
    }
  }, [locale, tGeneral, handleCloseModal]);

  const handleBillFormSubmit = useCallback(async (formData: Omit<Bill, 'id'>, currentBillId?: string) => {
    setIsModalLoading(true);
    setError(null);

    const method = currentBillId ? 'PUT' : 'POST';
    const url = currentBillId ? `/${locale}/api/bills/${currentBillId}` : `/${locale}/api/bills`;

    try {
      const res = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || tGeneral('errors.failed_fetch'));
      }

      handleCloseModal();
      fetchBillsForDate(currentDate);

    } catch (err: any) {
      console.error("Error submitting bill form:", err); // Log the error
      setError(err.message || (currentBillId ? tBillForm('edit_error') : tBillForm('add_error')));
    } finally {
      setIsModalLoading(false);
    }
  }, [locale, tGeneral, tBillForm, handleCloseModal, fetchBillsForDate, currentDate]);

  const handleOpenConfirmDelete = useCallback((id: number) => {
    setBillToDeleteId(id);
    setOpenConfirmDelete(true);
    setDeleteError(null);
  }, []);

  const handleCloseConfirmDelete = useCallback(() => {
    setOpenConfirmDelete(false);
    setBillToDeleteId(null);
    setDeleteError(null);
  }, []);

  const handleDeleteBill = useCallback(async () => {
    if (billToDeleteId === null) return;

    setOpenConfirmDelete(false);
    setIsDeleting(true);
    setDeleteError(null);

    try {
      const res = await fetch(`/${locale}/api/bills/${billToDeleteId}`, {
        method: 'DELETE',
      });

      if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || tGeneral('edit.delete_bill_error', { error: '' }));
      }

      setBillToDeleteId(null);
      fetchBillsForDate(currentDate);

    } catch (err: any) {
      console.error("Error deleting bill:", err); // Log the error
      setDeleteError(err.message || tGeneral('errors.failed_fetch'));
    } finally {
      setIsDeleting(false);
    }
  }, [billToDeleteId, locale, tGeneral, fetchBillsForDate, currentDate]);

  const handlePreviousDay = useCallback(() => {
    setCurrentDate(prevDate => subDays(prevDate, 1));
  }, []);

  const handleNextDay = useCallback(() => {
    setCurrentDate(prevDate => addDays(prevDate, 1));
  }, []);

  let content;

  if (status === 'loading' || (loading && !isModalOpen && !isDeleting)) {
    content = (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '80vh' }}>
        <CircularProgress />
      </Box>
    );
  } else if (status === 'authenticated') {
    content = (
      <>
        <Typography variant="h4" gutterBottom>
          {t('title')}
        </Typography>

        {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
        {deleteError && <Alert severity="error" sx={{ mb: 2 }}>{deleteError}</Alert>}
        {isDeleting && <Alert severity="info" sx={{ mb: 2 }}>{tGeneral('edit.deleting')}</Alert>}

        <Box sx={{ mb: 3 }}>
          <Button variant="contained" onClick={handleOpenAddModal}>
            {t('add_bill_entry')}
          </Button>
        </Box>

        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mt: 4, mb: 2 }}>
          <IconButton onClick={handlePreviousDay} aria-label="previous day"
            sx={{ color: 'inherit' }}
          >
            <ArrowBackIosIcon />
          </IconButton>
          <Typography
            variant={isMobile ? "h6" : "h5"}
            sx={{ flexGrow: 1, textAlign: 'center', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}
          >
            {t('summary_for_date', { date: formattedCurrentDate })}
          </Typography>
          <IconButton onClick={handleNextDay} aria-label="next day"
            sx={{ color: 'inherit' }}
          >
            <ArrowForwardIosIcon />
          </IconButton>
        </Box>

        {loading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', my: 3 }}>
            <CircularProgress />
          </Box>
        )}

        {!loading && dailySummary && (
          <DailySummaryCard
            date={formattedCurrentDate}
            summary={dailySummary}
          />
        )}

        {!loading && billsForDate.length > 0 ? (
          <BillList
            bills={billsForDate}
            onEdit={handleOpenEditModal}
            onDelete={handleOpenConfirmDelete}
          />
        ) : !loading && (
          <Typography sx={{ mt: 2 }}>
            {t('no_entries_today')}
          </Typography>
        )}

        <Dialog open={isModalOpen} onClose={handleCloseModal} fullWidth maxWidth="sm">
          <DialogTitle>
            {editingBillId ? tBillForm('edit_title') : tBillForm('add_title')}
            <IconButton
              aria-label="close"
              onClick={handleCloseModal}
              sx={{
                position: 'absolute',
                right: 8,
                top: 8,
                color: (theme) => theme.palette.grey[500],
              }}
            >
              <CloseIcon />
            </IconButton>
          </DialogTitle>
          <DialogContent dividers>
            <BillForm
              key={editingBillId || 'add-bill-form'}
              billId={editingBillId}
              initialBill={initialBillData}
              onSubmit={handleBillFormSubmit}
              isSubmitting={isModalLoading}
              defaultDate={currentDate}
              onCancel={handleCloseModal}
            />
          </DialogContent>
        </Dialog>

        <Dialog
          open={openConfirmDelete}
          onClose={handleCloseConfirmDelete}
          aria-labelledby="alert-dialog-title"
          aria-describedby="alert-dialog-description"
        >
          <DialogTitle id="alert-dialog-title">{tGeneral('edit.delete_confirm_title')}</DialogTitle>
          <DialogContent>
            <DialogContentText id="alert-dialog-description">
              {tGeneral('edit.delete_confirm_message', { id: billToDeleteId ?? '' })}
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={handleCloseConfirmDelete} disabled={isDeleting}>{tGeneral('edit.cancel')}</Button>
            <Button onClick={handleDeleteBill} color="error" autoFocus disabled={isDeleting}>
              {isDeleting ? <CircularProgress size={24} /> : tGeneral('edit.delete')}</Button>
          </DialogActions>
        </Dialog>
      </>
    );
  } else {
    content = null;
  }

  return content;
};

export default DashboardPageClient;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/SessionProvider.tsx
TYPE: typescript-react
CONTENT:
```
// src/components/SessionProvider.tsx
"use client"; // This directive MUST be the very first line

import { SessionProvider as NextAuthSessionProvider } from 'next-auth/react';
import { Session } from 'next-auth';
import { ReactNode } from 'react';

interface SessionProviderProps {
  children: ReactNode;
  session: Session | null;
}

export function SessionProvider({ children, session }: SessionProviderProps) {
  return (
    <NextAuthSessionProvider session={session}>
      {children}
    </NextAuthSessionProvider>
  );
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/ThemeToggleButton.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useContext } from 'react';
import IconButton from '@mui/material/IconButton';
import Brightness4Icon from '@mui/icons-material/Brightness4'; // Moon icon for dark mode
import Brightness7Icon from '@mui/icons-material/Brightness7'; // Sun icon for light mode
import { ThemeContext } from './ThemeProviderWrapper'; // Import the ThemeContext

const ThemeToggleButton: React.FC = () => {
  const themeContext = useContext(ThemeContext);

  if (!themeContext) {
    // This should ideally not happen if ThemeProviderWrapper is correctly wrapping the app
    console.error('ThemeContext not found. Ensure ThemeToggleButton is wrapped by ThemeProviderWrapper.');
    return null;
  }

  const { toggleTheme, mode } = themeContext;

  return (
    <IconButton onClick={toggleTheme} color="inherit" aria-label="toggle theme">
      {mode === 'dark' ? <Brightness7Icon /> : <Brightness4Icon />}
    </IconButton>
  );
};

export default ThemeToggleButton;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/LanguageSwitcherSelect.tsx
TYPE: typescript-react
CONTENT:
```
// src/components/LanguageSwitcherSelect.tsx
// This is a Client Component that handles the actual locale selection and change
// using next/navigation to change the route and thus the locale.
"use client";

// Import hooks from react
import { useState, useTransition, ChangeEvent, ReactNode } from 'react';
// Import hooks from next/navigation
import { useParams, useRouter, usePathname } from 'next/navigation';
// Import MUI components
import Box from '@mui/material/Box';
import Button from '@mui/material/Button';
import Menu from '@mui/material/Menu';
import MenuItem from '@mui/material/MenuItem';
import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown';
// useTranslations is from 'next-intl', but we'll pass it down from the parent
// import { useTranslations } from 'next-intl';


// Define props for this component
interface LanguageSwitcherSelectProps {
  // We'll pass the current locale and translation function from the parent
  currentLocale: string;
  t: (key: string) => string; // Simplified type for translation function
}

const LanguageSwitcherSelect: React.FC<LanguageSwitcherSelectProps> = ({ currentLocale, t }) => {
  // Use Next.js router for navigation
  const router = useRouter();
  // Use Next.js hooks to get current path and params
  const pathname = usePathname();
  const params = useParams();

  // Hook for pending state during transition
  const [isPending, startTransition] = useTransition();

  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const open = Boolean(anchorEl);

  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleMenuItemClick = (nextLocale: string) => {
    // Manually construct the new path with the selected locale
    // Assuming the locale is the first segment in the path (e.g., /en/dashboard)
    // This approach might need adjustment based on your exact routing structure
    const segments = pathname.split('/');
    // Replace the current locale segment with the new locale
    segments[1] = nextLocale;
    const newPath = segments.join('/');

    // Start a transition when changing locale
    startTransition(() => {
      // Use router.replace to change the route, which triggers the locale change
      router.replace(newPath);
    });
    handleClose();
  };

  return (
    <Box sx={{ ml: 1 }}> {/* Add some margin */}
       <Button
           id="language-switcher-button"
           aria-controls={open ? 'language-switcher-menu' : undefined}
           aria-haspopup="true"
           aria-expanded={open ? 'true' : undefined}
           onClick={handleClick}
           color="inherit"
           endIcon={<ArrowDropDownIcon />} // Keep MUI icon
           disabled={isPending} // Disable button while transitioning
       >
           {/* Display current locale or a label */}
           {currentLocale.toUpperCase()}
       </Button>
       <Menu
           id="language-switcher-menu"
           anchorEl={anchorEl}
           open={open}
           onClose={handleClose}
           MenuListProps={{
               'aria-labelledby': 'language-switcher-button',
           }}
       >
           {/* Add MenuItems for each supported locale */}
           {/* Replace with your actual supported locales */}
           <MenuItem onClick={() => handleMenuItemClick('en')} selected={currentLocale === 'en'}>
               English
           </MenuItem>
           <MenuItem onClick={() => handleMenuItemClick('ja')} selected={currentLocale === 'ja'}>
               日本語
           </MenuItem>
           {/* Add more MenuItems for other locales if needed */}
       </Menu>
    </Box>
  );
};

export default LanguageSwitcherSelect;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/PurchaseBillList.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useCallback } from 'react'; // Added useCallback
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Typography,
  Box,
  IconButton,
  useMediaQuery,
  useTheme,
  List,
  ListItem,
  ListItemText,
  Grid,
} from '@mui/material';
import { Edit as EditIcon, Delete as DeleteIcon } from '@mui/icons-material';
import { useTranslations } from 'next-intl';
import { format, parseISO } from 'date-fns';

interface PurchaseBill {
  id: string;
  date: string;
  amount: number;
  description: string;
  comments?: string | null;
}

interface PurchaseBillListProps {
  purchaseBills: PurchaseBill[];
  onEdit: (purchaseBillId: string) => void;
  onDelete: (purchaseBillId: string) => void;
}

const PurchaseBillList: React.FC<PurchaseBillListProps> = ({ purchaseBills, onEdit, onDelete }) => {
  const t = useTranslations('purchase_bill_list');
  const tErrors = useTranslations('errors');
  const tGeneral = useTranslations('general');

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const formatCurrency = useCallback((amount: number | string) => { // Using useCallback
    let numericAmount: number;
    if (typeof amount === 'string') {
      const cleanedString = amount.replace(/[¥,]/g, '');
      numericAmount = Number(cleanedString);
    } else {
      numericAmount = amount;
    }
    if (isNaN(numericAmount)) {
      numericAmount = 0;
    }
    return `¥${numericAmount.toLocaleString()}`;
  }, []);

  const handleDeleteClick = useCallback((billId: string) => { // Using useCallback
    onDelete(billId);
  }, [onDelete]);

  if (!purchaseBills || purchaseBills.length === 0) {
    return (
      <Paper elevation={2} sx={{ p: 2, mb: 2, textAlign: 'center', borderRadius: 2 }}>
        <Typography variant="body1">{tErrors('no_purchase_bills_found')}</Typography>
      </Paper>
    );
  }

  return (
    <Box sx={{ width: '100%' }}>
      {isMobile ? (
        <List sx={{ width: '100%', bgcolor: 'background.paper', p: 0 }}>
          {purchaseBills.map((pb) => (
            <Paper key={pb.id} elevation={2} sx={{ mb: 2, p: 2, borderRadius: 2 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('date')}:</Typography>
                <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium' }}>
                  {format(parseISO(pb.date), 'yyyy-MM-dd')}
                </Typography>
              </Box>
              
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('amount')}:</Typography>
                <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium' }}>
                  {formatCurrency(pb.amount)}
                </Typography>
              </Box>

              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('description')}:</Typography>
                <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium', textAlign: 'right', flexGrow: 1, ml: 1 }}>
                  {pb.description}
                </Typography>
              </Box>

              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                <Typography variant="body2" color="text.secondary">{t('comments')}:</Typography>
                <Typography component="span" variant="body1" color="text.primary" sx={{ fontWeight: 'medium', textAlign: 'right', flexGrow: 1, ml: 1 }}>
                  {pb.comments || '-'}
                </Typography>
              </Box>
              
              <Box sx={{ display: 'flex', justifyContent: 'flex-end', pt: 2, borderTop: '1px solid', borderColor: 'divider', mt: 1 }}>
                <IconButton onClick={() => onEdit(pb.id.toString())} color="primary" aria-label={tGeneral('edit_button')}>
                  <EditIcon />
                </IconButton>
                <IconButton onClick={() => handleDeleteClick(pb.id.toString())} color="error" aria-label={tGeneral('delete')}>
                  <DeleteIcon />
                </IconButton>
              </Box>
            </Paper>
          ))}
        </List>
      ) : (
        <TableContainer component={Paper} elevation={3} sx={{ borderRadius: 3 }}>
          <Table sx={{ minWidth: 650 }} aria-label="purchase bill list">
            <TableHead>
              <TableRow>
                <TableCell>{t('date')}</TableCell>
                <TableCell align="right">{t('amount')}</TableCell>
                <TableCell>{t('description')}</TableCell>
                <TableCell>{t('comments')}</TableCell>
                <TableCell align="center">{t('actions')}</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {purchaseBills.map((pb) => (
                <TableRow key={pb.id}>
                  <TableCell component="th" scope="row">
                    {format(parseISO(pb.date), 'yyyy-MM-dd')}
                  </TableCell>
                  <TableCell align="right">{formatCurrency(pb.amount)}</TableCell>
                  <TableCell>{pb.description}</TableCell>
                  <TableCell sx={{ maxWidth: 200, overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                    {pb.comments || '-'}
                  </TableCell>
                  <TableCell align="center">
                    <IconButton onClick={() => onEdit(pb.id.toString())} color="primary" aria-label={tGeneral('edit_button')}>
                      <EditIcon />
                    </IconButton>
                    <IconButton onClick={() => handleDeleteClick(pb.id.toString())} color="error" aria-label={tGeneral('delete')}>
                      <DeleteIcon />
                    </IconButton>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}
    </Box>
  );
};

export default PurchaseBillList;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/Layout.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { ReactNode, useCallback } from 'react'; // Added useCallback
import { AppBar, Toolbar, Typography, Container, Box, Button, IconButton, useMediaQuery, useTheme } from '@mui/material';
import Link from 'next/link';
import { useTranslations } from 'next-intl';
import { useSession, signOut } from 'next-auth/react';
import LanguageSwitcher from './LanguageSwitcher';
import ThemeToggleButton from './ThemeToggleButton';
import MenuIcon from '@mui/icons-material/Menu';
import Drawer from '@mui/material/Drawer';
import List from '@mui/material/List';
import ListItem from '@mui/material/ListItem';
import ListItemButton from '@mui/material/ListItemButton';
import ListItemText from '@mui/material/ListItemText';
import Divider from '@mui/material/Divider';
import { useRouter, useParams } from 'next/navigation';

interface LayoutProps {
  children: ReactNode;
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const t = useTranslations('layout');
  const { data: session, status } = useSession();
  const isAuthenticated = status === 'authenticated';

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const [mobileOpen, setMobileOpen] = React.useState(false);

  const router = useRouter();
  const params = useParams();
  const currentLocale = params.locale as string || 'en';

  const handleDrawerToggle = useCallback(() => { // Using useCallback
    setMobileOpen((prev) => !prev);
  }, []);

  const drawer = (
    <Box
      onClick={handleDrawerToggle}
      sx={{
        textAlign: 'center',
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
      }}
    >
      <Typography variant="h6" sx={{ my: 2 }}>
        {t('app_title')}
      </Typography>
      <List sx={{ flexGrow: 1 }}>
        {isAuthenticated && (
          <>
            <ListItem disablePadding>
              <ListItemButton component={Link} href={`/${currentLocale}/dashboard`}>
                <ListItemText primary={t('dashboard_link')} />
              </ListItemButton>
            </ListItem>
            <ListItem disablePadding>
              <ListItemButton component={Link} href={`/${currentLocale}/purchases`}>
                <ListItemText primary={t('purchases_link')} />
              </ListItemButton>
            </ListItem>
            <ListItem disablePadding>
              <ListItemButton component={Link} href={`/${currentLocale}/summary`}>
                <ListItemText primary={t('summary_link')} />
              </ListItemButton>
            </ListItem>
            <ListItem disablePadding>
              <ListItemButton onClick={() => signOut({ callbackUrl: `/${currentLocale}` })}>
                <ListItemText primary={t('sign_out_button')} />
              </ListItemButton>
            </ListItem>
          </>
        )}
      </List>
      
      {isAuthenticated && <Divider sx={{ my: 1 }} />}
      <Box sx={{ p: 2, display: 'flex', justifyContent: 'space-around', alignItems: 'center' }}>
        <LanguageSwitcher />
        <ThemeToggleButton />
      </Box>
    </Box>
  );

  return (
    <Box sx={{ flexGrow: 1 }}>
      <AppBar position="static" sx={{ borderRadius: 0 }}>
        <Toolbar sx={{ flexWrap: 'wrap', justifyContent: 'space-between' }}>
          {isMobile && isAuthenticated && (
            <IconButton
              color="inherit"
              aria-label="open drawer"
              edge="start"
              onClick={handleDrawerToggle}
              sx={{ mr: 2 }}
            >
              <MenuIcon />
            </IconButton>
          )}

          <Box sx={{ display: 'flex', alignItems: 'center', flexGrow: 1 }}>
            <Link href={`/${currentLocale}`} style={{ textDecoration: 'none', color: 'inherit', display: 'flex', alignItems: 'center' }}>
              <img
                src="/phulka.png"
                alt="Phulkas App Logo"
                style={{ height: 50, width: 50, borderRadius: '50%', marginRight: 8 }}
                onError={(e: React.SyntheticEvent<HTMLImageElement, Event>) => {
                  e.currentTarget.src = "https://placehold.co/50x50/CCCCCC/000000?text=LOGO";
                }}
              />
              <Typography variant="h6" component="div" sx={{ display: 'block' }}>
                {t('app_title')}
              </Typography>
            </Link>
          </Box>

          {!isMobile && isAuthenticated && (
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Button color="inherit" component={Link} href={`/${currentLocale}/dashboard`}>
                {t('dashboard_link')}
              </Button>
              <Button color="inherit" component={Link} href={`/${currentLocale}/purchases`}>
                {t('purchases_link')}
              </Button>
              <Button color="inherit" component={Link} href={`/${currentLocale}/summary`}>
                {t('summary_link')}
              </Button>
              <Button color="inherit" onClick={() => signOut({ callbackUrl: `/${currentLocale}` })}>
                {t('sign_out_button')}
              </Button>
            </Box>
          )}

          {!isMobile && (
            <Box sx={{ display: 'flex', alignItems: 'center', ml: 2 }}>
              <LanguageSwitcher />
              <ThemeToggleButton />
            </Box>
          )}
        </Toolbar>
      </AppBar>

      <nav>
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true,
          }}
          sx={{
            display: { xs: 'block', sm: 'none' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: 240, display: 'flex', flexDirection: 'column' },
          }}
        >
          {drawer}
        </Drawer>
      </nav>

      <Container sx={{ mt: 4 }}>
        {children}
      </Container>
    </Box>
  );
};

export default Layout;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/ConfigPageClient.tsx
TYPE: typescript-react
CONTENT:
```
// src/components/ConfigPageClient.tsx
"use client";

import React from 'react';
import { Typography, Box } from '@mui/material';
import AppConfigForm from '@/components/AppConfigForm';

interface ConfigPageClientProps {
  title: string;
}

const ConfigPageClient: React.FC<ConfigPageClientProps> = ({ title }) => {
  return (
    <Box sx={{ py: 4 }}>
      <Typography variant="h4" component="h1" gutterBottom>
        {title}
      </Typography>
      <AppConfigForm />
    </Box>
  );
};

export default ConfigPageClient;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/BillForm.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useState, useEffect, useCallback, useMemo } from 'react'; // Added useCallback
import {
  TextField,
  Button,
  Box,
  Typography,
  MenuItem,
  Checkbox,
  FormControlLabel,
  CircularProgress,
  Alert,
  FormControl,
  InputLabel,
  Select,
  FormHelperText,
} from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { format, parseISO, isValid } from 'date-fns';
import { useTranslations } from 'next-intl';
import { useRouter } from 'next/navigation';
import { Bill } from '@/types/Bill';
import { enUS, ja } from 'date-fns/locale';

interface BillFormProps {
  billId?: string;
  initialBill?: Bill;
  onSubmit: (data: Omit<Bill, 'id'>, currentBillId?: string) => void;
  isSubmitting?: boolean;
  defaultDate?: Date;
  onCancel: () => void;
}

const BillForm: React.FC<BillFormProps> = ({ billId, initialBill, onSubmit, isSubmitting, defaultDate, onCancel }) => {
  const t = useTranslations('bill_form');
  const tMealType = useTranslations('meal_type');
  const tErrors = useTranslations('errors');
  const tGeneral = useTranslations('general');

  const router = useRouter();
  const locale = router.locale as string;

  const [date, setDate] = useState<Date | null>(
    initialBill?.date ? parseISO(initialBill.date) : (defaultDate || new Date())
  );
  const [foodAmount, setFoodAmount] = useState<number | ''>(initialBill?.foodAmount ?? 0);
  const [drinkAmount, setDrinkAmount] = useState<number | ''>(initialBill?.drinkAmount ?? 0);
  const [mealType, setMealType] = useState<Bill['mealType']>(initialBill?.mealType ?? 'lunch');
  const [isOurFood, setIsOurFood] = useState<boolean>(initialBill?.isOurFood ?? true);
  const [numberOfPeopleWorkingDinner, setNumberOfPeopleWorkingDinner] = useState<number | ''>(initialBill?.numberOfPeopleWorkingDinner ?? 1);
  const [comments, setComments] = useState<string>(initialBill?.comments ?? '');

  const [error, setError] = useState<{ [key: string]: string }>({});
  const [formError, setFormError] = useState<string | null>(null);

  const dateFnsLocale = useMemo(() => {
    return locale === 'ja' ? ja : enUS;
  }, [locale]);

  useEffect(() => {
    if (initialBill) {
      setDate(parseISO(initialBill.date));
      setFoodAmount(initialBill.foodAmount);
      setDrinkAmount(initialBill.drinkAmount);
      setMealType(initialBill.mealType);
      setIsOurFood(initialBill.isOurFood);
      setNumberOfPeopleWorkingDinner(initialBill.numberOfPeopleWorkingDinner ?? 1);
      setComments(initialBill.comments ?? '');
    } else if (defaultDate) {
      setDate(defaultDate);
      setFoodAmount(0);
      setDrinkAmount(0);
      setMealType('lunch');
      setIsOurFood(true);
      setNumberOfPeopleWorkingDinner(1);
      setComments('');
    }
    setFormError(null);
    setError({});
  }, [initialBill, defaultDate]);

  const validateForm = useCallback(() => { // Using useCallback
    const newErrors: { [key: string]: string } = {};

    if (!date || !isValid(date)) {
      newErrors.date = tErrors('invalid_date');
    }

    if (foodAmount === '' || foodAmount < 0) {
      newErrors.foodAmount = tErrors('positive_number');
    }

    if (drinkAmount === '' || drinkAmount < 0) {
      newErrors.drinkAmount = tErrors('positive_number');
    }

    if (mealType === 'dinner' && (numberOfPeopleWorkingDinner === '' || numberOfPeopleWorkingDinner < 1)) {
      newErrors.numberOfPeopleWorkingDinner = t('num_people_min');
    }

    setError(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [date, foodAmount, drinkAmount, mealType, numberOfPeopleWorkingDinner, tErrors, t]);

  const handleSubmit = useCallback(async (e: React.FormEvent) => { // Using useCallback
    e.preventDefault();

    if (!validateForm()) {
      setFormError(tGeneral('errors.form_validation_failed') || 'Please correct the errors in the form.');
      return;
    }
    setFormError(null);

    const formattedDate = date ? format(date, 'yyyy-MM-dd') : '';

    const formData: Omit<Bill, 'id'> = {
      date: formattedDate,
      foodAmount: Number(foodAmount),
      drinkAmount: Number(drinkAmount),
      mealType,
      isOurFood,
      numberOfPeopleWorkingDinner: mealType === 'dinner' ? Number(numberOfPeopleWorkingDinner) : 1,
      comments: comments.trim() || null,
    };

    onSubmit(formData, billId);
  }, [date, foodAmount, drinkAmount, mealType, isOurFood, numberOfPeopleWorkingDinner, comments, onSubmit, billId, validateForm, tGeneral]);

  return (
    <Box component="form" onSubmit={handleSubmit} noValidate sx={{ mt: 1 }}>
      {formError && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {formError}
        </Alert>
      )}

      <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={dateFnsLocale}>
        <DatePicker
          label={t('date_label')}
          value={date}
          onChange={(newDate) => setDate(newDate)}
          slotProps={{ textField: { fullWidth: true, margin: "normal", error: !!error.date, helperText: error.date } }}
          format="yyyy-MM-dd"
        />
      </LocalizationProvider>

      <FormControl fullWidth margin="normal" error={!!error.mealType}>
        <InputLabel id="meal-type-label">{t('meal_type_label')}</InputLabel>
        <Select
          labelId="meal-type-label"
          id="meal-type"
          value={mealType}
          label={t('meal_type_label')}
          onChange={(e) => setMealType(e.target.value as Bill['mealType'])}
        >
          <MenuItem value="lunch">{tMealType('lunch')}</MenuItem>
          <MenuItem value="dinner">{tMealType('dinner')}</MenuItem>
        </Select>
        {error.mealType && <FormHelperText>{error.mealType}</FormHelperText>}
      </FormControl>

      <TextField
        label={t('food_amount_label')}
        value={foodAmount}
        onChange={(e) => setFoodAmount(e.target.value === '' ? '' : Number(e.target.value))}
        fullWidth
        margin="normal"
        type="number"
        inputProps={{ min: 0 }}
        error={!!error.foodAmount}
        helperText={error.foodAmount}
      />

      <TextField
        label={t('drink_amount_label')}
        value={drinkAmount}
        onChange={(e) => setDrinkAmount(e.target.value === '' ? '' : Number(e.target.value))}
        fullWidth
        margin="normal"
        type="number"
        inputProps={{ min: 0 }}
        error={!!error.drinkAmount}
        helperText={error.drinkAmount}
      />

      {mealType === 'dinner' && (
        <>
          <FormControlLabel
            control={<Checkbox checked={isOurFood} onChange={(e) => setIsOurFood(e.target.checked)} />}
            label={t('is_our_food_label')}
          />
          <TextField
            label={t('num_people_working_label')}
            value={numberOfPeopleWorkingDinner}
            onChange={(e) => setNumberOfPeopleWorkingDinner(e.target.value === '' ? '' : Number(e.target.value))}
            fullWidth
            margin="normal"
            type="number"
            inputProps={{ min: 1 }}
            error={!!error.numberOfPeopleWorkingDinner}
            helperText={error.numberOfPeopleWorkingDinner}
          />
        </>
      )}

      <TextField
        label={t('comments_label')}
        value={comments}
        onChange={(e) => setComments(e.target.value)}
        fullWidth
        multiline
        rows={4}
        margin="normal"
        sx={{
          '& .MuiInputLabel-root': {
            transform: 'translate(14px, 14px) scale(1)',
          },
          '& .MuiInputLabel-shrink': {
            transform: 'translate(14px, -9px) scale(0.75)',
          },
          '& .MuiOutlinedInput-root': {
            paddingTop: '18px',
          },
        }}
      />

      <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 2 }}>
        <Button onClick={onCancel} sx={{ mr: 2 }} disabled={isSubmitting}>
          {t('cancel')}
        </Button>
        <Button type="submit" variant="contained" color="primary" disabled={isSubmitting}>
          {isSubmitting ? <CircularProgress size={24} /> : t('save_button')}
        </Button>
      </Box>
    </Box>
  );
};

export default BillForm;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/InterpolationTest.tsx
TYPE: typescript-react
CONTENT:
```
// src/components/InterpolationTest.tsx
"use client";

import React from 'react';
import Typography from '@mui/material/Typography';
import { useTranslations } from 'next-intl';

const InterpolationTest: React.FC = () => {
  const t = useTranslations('dashboard');
  const testKey = 'todays_entries';
  const testValue = 'HARDCODED_TEST_DATE';
  const interpolatedText = t(testKey, { date: testValue });

  return (
    <Typography variant="h6" color="secondary" sx={{ mt: 2, border: '1px dashed red', p: 1 }}>
      Interpolation Test Component Output (next-intl): {interpolatedText}
    </Typography>
  );
};

export default InterpolationTest;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/AuthProvider.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import { SessionProvider } from 'next-auth/react';
import React, { ReactNode } from 'react';

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => { // This is a NAMED export
  return (
    <SessionProvider>
      {children}
    </SessionProvider>
  );
};

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/DailyBillSummary.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useMemo } from 'react';
import {
  Card,
  CardContent,
  Typography,
  List,
  ListItem,
  ListItemText,
  Divider,
  Box,
  Button,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import { useTranslations } from 'next-intl';
import { format, parseISO } from 'date-fns';
import { enUS, ja } from 'date-fns/locale';

import { DailySummary, MealSummary } from '@/lib/calculations';

interface DailyBillSummaryProps {
  date: string; // The selected date in 'yyyy-MM-dd' format
  dailySummary: DailySummary; // Now expects a DailySummary object
  locale: string;
  onClose: () => void; // Function to close the summary
}

const MealSummaryDisplay: React.FC<{
  title: string;
  summary: MealSummary;
  locale: string;
  tGeneral: (key: string) => string;
}> = ({ title, summary, locale, tGeneral }) => (
  <Box sx={{ mb: 2 }}>
    <Typography variant="h6" component="h3" gutterBottom>
      {title}
    </Typography>
    <Typography variant="body2">
      {tGeneral('summary.food_total')}: ¥{summary.rawFoodTotal.toLocaleString(locale)} {/* Changed from raw_food_total */}
    </Typography>
    <Typography variant="body2">
      {tGeneral('summary.drink_total')}: ¥{summary.rawDrinkTotal.toLocaleString(locale)} {/* Changed from raw_drink_total */}
    </Typography>
    <Typography variant="body1" color="primary" sx={{ fontWeight: 'bold', mt: 1 }}>
      {tGeneral('summary.total_earnings_label')}: ¥{summary.phulkasEarnings.toLocaleString(locale)} {/* Changed from phulkas_earnings */}
    </Typography>
    {summary.isOurFood !== undefined && (
      <Typography variant="body2">
        {tGeneral('summary.is_our_food_label')}: {summary.isOurFood ? tGeneral('general.yes') : tGeneral('general.no')}
      </Typography>
    )}
    {summary.numberOfPeopleWorkingDinner !== undefined && (
      <Typography variant="body2">
        {tGeneral('summary.num_people_working_label')}: {summary.numberOfPeopleWorkingDinner}
      </Typography>
    )}
  </Box>
);


const DailyBillSummary: React.FC<DailyBillSummaryProps> = ({ date, dailySummary, locale, onClose }) => {
  const t = useTranslations('summary');
  const tGeneral = useTranslations();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const dateFnsLocale = useMemo(() => {
    return locale === 'ja' ? ja : enUS;
  }, [locale]);

  const formattedDate = format(parseISO(date), 'PPP', { locale: dateFnsLocale });

  return (
    <Card sx={{ mt: 4, mb: 4, borderRadius: 3, boxShadow: 3, width: '100%' }}>
      <CardContent>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
          <Typography variant="h5" component="h2">
            {t('daily_summary_for', { date: formattedDate })}
          </Typography>
          <Button onClick={onClose} variant="outlined" size="small">
            {tGeneral('general.close')}
          </Button>
        </Box>
        <Divider sx={{ my: 2 }} />

        {dailySummary.lunch.phulkasEarnings > 0 || dailySummary.lunch.rawFoodTotal > 0 || dailySummary.lunch.rawDrinkTotal > 0 ? (
          <MealSummaryDisplay
            title={tGeneral('summary.lunch_summary_title')}
            summary={dailySummary.lunch}
            locale={locale}
            tGeneral={tGeneral}
          />
        ) : (
          <Typography variant="body2" sx={{ mb: 2 }}>{tGeneral('summary.no_lunch_entries')}</Typography>
        )}

        <Divider sx={{ my: 2 }} />

        {dailySummary.dinner.phulkasEarnings > 0 || dailySummary.dinner.rawFoodTotal > 0 || dailySummary.dinner.rawDrinkTotal > 0 ? (
          <MealSummaryDisplay
            title={tGeneral('summary.dinner_summary_title')}
            summary={dailySummary.dinner}
            locale={locale}
            tGeneral={tGeneral}
          />
        ) : (
          <Typography variant="body2" sx={{ mb: 2 }}>{tGeneral('summary.no_dinner_entries')}</Typography>
        )}

        <Divider sx={{ my: 2 }} />

        <Typography variant="h5" color="primary" sx={{ fontWeight: 'bold', mt: 2 }}>
          {t('total_daily_earnings', { amount: dailySummary.dayTotalEarnings.toLocaleString(locale) })}
        </Typography>

      </CardContent>
    </Card>
  );
};

export default DailyBillSummary;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/DailySummaryCard.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React from 'react';
import { Box, Typography, Paper, Grid, useTheme, useMediaQuery } from '@mui/material';
import { useTranslations } from 'next-intl';
import { DailySummary, MealSummary } from '@/lib/calculations'; // Ensure these types are correct
import { AppConfig } from '@/config/app'; // Ensure this path is correct

interface DailySummaryCardProps {
  date?: string;
  summary: DailySummary | null;
}

const DailySummaryCard: React.FC<DailySummaryCardProps> = ({ date, summary }) => {
  const t = useTranslations('dashboard');
  const tEarnings = useTranslations('earnings_details');

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  if (!summary) {
    return (
      <Paper elevation={2} sx={{ p: 2, mb: 2, textAlign: 'center' }}>
        <Typography variant="body1">{t('no_summary_data')}</Typography>
      </Paper>
    );
  }

  const { lunch, dinner, dayTotalEarnings } = summary;

  // FIX: Make formatCurrency robust to handle potential null/undefined amounts
  const formatCurrency = (amount: number | string | null | undefined) => {
    let numericAmount: number;

    if (typeof amount === 'string') {
      const cleanedString = amount.replace(/[¥,]/g, '');
      numericAmount = Number(cleanedString);
    } else {
      numericAmount = amount ?? 0; // Default to 0 if null or undefined
    }

    if (isNaN(numericAmount)) {
      numericAmount = 0;
    }

    return `¥${numericAmount.toLocaleString()}`;
  };

  const renderMealDetails = (meal: 'lunch' | 'dinner', mealSummary: MealSummary) => {
    const isLunch = meal === 'lunch';
    
    // Ensure these properties are handled safely, providing defaults if they might be missing
    const isOurFood = mealSummary.isOurFood ?? true;
    const numberOfPeopleWorkingDinner = mealSummary.numberOfPeopleWorkingDinner ?? 1;
    const effectiveWorkers = Math.max(1, numberOfPeopleWorkingDinner);

    let directFoodEarningsDisplay = 0;
    let commonPoolFoodContributionDisplay = 0;
    let commonPoolDrinkContributionDisplay = 0;
    let totalCommonPoolDisplay = 0;
    let ourShareFromCommonPoolDisplay = 0;

    if (!isLunch) {
      if (isOurFood) {
        directFoodEarningsDisplay = (mealSummary.rawFoodTotal ?? 0) * AppConfig.DINNER_FOOD_OUR_SHARE_PERCENT;
      } else {
        directFoodEarningsDisplay = 0;
      }
      
      commonPoolFoodContributionDisplay = (mealSummary.rawFoodTotal ?? 0) * AppConfig.DINNER_FOOD_COMMON_POOL_PERCENT;
      commonPoolDrinkContributionDisplay = (mealSummary.rawDrinkTotal ?? 0) * AppConfig.DINNER_DRINK_COMMON_POOL_PERCENT;
      
      totalCommonPoolDisplay = commonPoolFoodContributionDisplay + commonPoolDrinkContributionDisplay;
      ourShareFromCommonPoolDisplay = totalCommonPoolDisplay / effectiveWorkers;
    }

    return (
      <Box sx={{ mt: 1 }}>
        <Typography variant="subtitle1" sx={{ fontWeight: 'bold', color: theme.palette.text.primary }}> {/* Explicitly set color for readability */}
          {t(`${meal}_summary`)}
        </Typography>

        <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>{t('food_bills_total', { amount: formatCurrency(mealSummary.rawFoodTotal) })}</Typography>
        <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>{t('drink_bills_total', { amount: formatCurrency(mealSummary.rawDrinkTotal) })}</Typography>

        {isLunch ? (
          <>
            <Typography variant="caption" display="block" sx={{ mt: 1, color: theme.palette.text.secondary }}> {/* Explicitly set color */}
              {tEarnings('lunch_food_base_income', { base: formatCurrency(AppConfig.LUNCH_FOOD_BASE_INCOME) })}
            </Typography>
            {mealSummary.rawFoodTotal > AppConfig.LUNCH_FOOD_BASE_INCOME && (
              <Typography variant="caption" display="block" sx={{ color: theme.palette.text.secondary }}> {/* Explicitly set color */}
                {tEarnings('lunch_food_overage', {
                  overage: formatCurrency(Math.max(0, (mealSummary.rawFoodTotal ?? 0) - AppConfig.LUNCH_FOOD_BASE_INCOME)),
                  overageHalf: formatCurrency(Math.max(0, (mealSummary.rawFoodTotal ?? 0) - AppConfig.LUNCH_FOOD_BASE_INCOME) * AppConfig.LUNCH_FOOD_OVERAGE_SHARE_PERCENT)
                })}
              </Typography>
            )}
            <Typography variant="caption" display="block" sx={{ color: theme.palette.text.secondary }}> {/* Explicitly set color */}
              {tEarnings('total_lunch_food_income_share', { amount: formatCurrency(mealSummary.foodEarnings) })}
            </Typography>
            <Typography variant="caption" display="block" sx={{ color: theme.palette.text.secondary }}> {/* Explicitly set color */}
              {tEarnings('drink_calc_lunch', {
                total: formatCurrency(mealSummary.rawDrinkTotal),
                percentage: AppConfig.LUNCH_DRINK_SHARE_PERCENT * 100,
                share: formatCurrency(mealSummary.drinkEarnings)
              })}
            </Typography>
          </>
        ) : (
          <>
            {isOurFood && directFoodEarningsDisplay > 0 && (
              <Typography variant="caption" display="block" sx={{ mt: 1, color: theme.palette.text.secondary }}> {/* Explicitly set color */}
                {tEarnings('dinner_food_direct_share', {
                  total: formatCurrency(mealSummary.rawFoodTotal),
                  share: formatCurrency(directFoodEarningsDisplay)
                })}
              </Typography>
            )}

            <Typography variant="caption" display="block" sx={{ mt: 1, color: theme.palette.text.secondary }}> {/* Explicitly set color */}
              {tEarnings('dinner_common_pool_contrib_food', { amount: formatCurrency(commonPoolFoodContributionDisplay) })}
            </Typography>
            <Typography variant="caption" display="block" sx={{ color: theme.palette.text.secondary }}> {/* Explicitly set color */}
              {tEarnings('dinner_common_pool_contrib_drinks', { amount: formatCurrency(commonPoolDrinkContributionDisplay) })}
            </Typography>
            <Typography variant="caption" display="block" sx={{ color: theme.palette.text.secondary }}> {/* Explicitly set color */}
              {tEarnings('total_common_pool', { amount: formatCurrency(totalCommonPoolDisplay) })}
            </Typography>
            <Typography variant="caption" display="block" sx={{ color: theme.palette.text.secondary }}> {/* Explicitly set color */}
              {tEarnings('our_common_pool_share', {
                amount: formatCurrency(ourShareFromCommonPoolDisplay),
                workers: effectiveWorkers
              })}
            </Typography>
          </>
        )}

        <Typography variant="body1" color="primary" sx={{ fontWeight: 'bold', mt: 1, color: theme.palette.text.primary }}> {/* Explicitly set color for readability */}
          {t(`phulkas_${meal}_earnings`, { amount: formatCurrency(mealSummary.phulkasEarnings) })}
        </Typography>
      </Box>
    );
  };

  return (
    <Paper
      elevation={3}
      sx={{
        p: 3,
        mb: 3,
        borderRadius: isMobile ? 2 : 3,
        mx: isMobile ? 1 : 'auto',
      }}
    >
      {date && (
        <Typography variant="h6" gutterBottom sx={{ color: theme.palette.text.primary }}> {/* Explicitly set color */}
          {t('summary_for_date', { date: date })}
        </Typography>
      )}

      <Grid container spacing={isMobile ? 1 : 3}>
        <Grid item xs={12} sm={6}> {/* Changed to `item` */}
          {renderMealDetails('lunch', lunch)}
        </Grid>

        <Grid item xs={12} sm={6}> {/* Changed to `item` */}
          {renderMealDetails('dinner', dinner)}
        </Grid>

        <Grid item xs={12} sx={{ mt: 2 }}> {/* Changed to `item` */}
          <Typography variant="h6" sx={{ fontWeight: 'bold', borderTop: '1px solid', borderColor: theme.palette.divider, pt: 1, color: theme.palette.text.primary }}> {/* Explicitly set color and border color */}
            {t('day_total_earnings_header')}: {formatCurrency(dayTotalEarnings)}
          </Typography>
        </Grid>
      </Grid>
    </Paper>
  );
};

export default DailySummaryCard;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/MuiRegistry.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import { CacheProvider } from '@emotion/react';
import createCache from '@emotion/cache';
import { EmotionCache } from '@emotion/cache';

export default function MuiRegistry({ children }: { children: React.ReactNode }) { // This is a DEFAULT export
  const [cache] = useState(() => {
    const cache = createCache({ key: 'mui' });
    cache.compat = true;
    return cache;
  });

  const [inserted] = useState<string[]>([]);

  useServerInsertedHTML(() => {
    const serialized = cache.sheet.tags.join('');
    if (serialized.length === 0) {
      return null;
    }
    if (inserted.includes(serialized)) {
      return null;
    }
    inserted.push(serialized);
    return (
      <style
        data-emotion={`${cache.key} ${serialized.substring(0, serialized.indexOf('{'))}`}
        dangerouslySetInnerHTML={{ __html: serialized }}
      />
    );
  });

  return <CacheProvider value={cache}>{children}</CacheProvider>;
}

```
--- FILE_END ---

--- FILE_START ---
PATH: src/components/LanguageSwitcher.tsx
TYPE: typescript-react
CONTENT:
```
"use client";

import React, { useState, useEffect, useCallback } from 'react'; // Added useCallback
import { useRouter, usePathname, useParams } from 'next/navigation';
import { useTranslations } from 'next-intl';
import Select from '@mui/material/Select';
import MenuItem from '@mui/material/MenuItem';
import FormControl from '@mui/material/FormControl';
import InputLabel from '@mui/material/InputLabel';
import { useTheme } from '@mui/material/styles';

const LanguageSwitcher: React.FC = () => {
  const router = useRouter();
  const pathname = usePathname();
  const params = useParams();
  const t = useTranslations('language_switcher');
  const theme = useTheme();

  const currentLocale = params.locale as string;
  const [locale, setLocale] = useState(currentLocale);

  useEffect(() => {
    if (currentLocale && currentLocale !== locale) {
      setLocale(currentLocale);
    }
  }, [currentLocale, locale]);

  const handleChange = useCallback((event: { target: { value: unknown } }) => { // Using useCallback
    const newLocale = event.target.value as string;
    setLocale(newLocale);

    const newPath = `/${newLocale}${pathname.substring(`/${currentLocale}`.length)}`;
    
    router.push(newPath);
    router.refresh();
  }, [currentLocale, pathname, router]);

  const desktopTextColor = theme.palette.primary.contrastText;
  const desktopBackgroundColor = theme.palette.primary.main;
  const desktopBorderColor = theme.palette.primary.dark;
  const desktopFocusedBorderColor = theme.palette.primary.light;

  const mobileTextColor = theme.palette.text.primary;
  const mobileBackgroundColor = 'transparent';
  const mobileBorderColor = theme.palette.divider;
  const mobileFocusedBorderColor = theme.palette.primary.main;

  return (
    <FormControl variant="outlined" size="small" sx={{ minWidth: 120 }}>
      <InputLabel 
        id="language-switcher-label" 
        sx={{ 
          color: { xs: mobileTextColor, md: desktopTextColor }
        }} 
      >
        {t('label')}
      </InputLabel>
      <Select
        labelId="language-switcher-label"
        value={locale}
        onChange={handleChange}
        label={t('label')}
        sx={{
          color: { xs: mobileTextColor, md: desktopTextColor },
          backgroundColor: { xs: mobileBackgroundColor, md: desktopBackgroundColor },
          borderRadius: theme.shape.borderRadius,
          '& .MuiOutlinedInput-notchedOutline': {
            borderColor: { xs: mobileBorderColor, md: desktopBorderColor },
          },
          '&:hover .MuiOutlinedInput-notchedOutline': {
            borderColor: { xs: mobileBorderColor, md: desktopBorderColor },
          },
          '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
            borderColor: { xs: mobileFocusedBorderColor, md: desktopFocusedBorderColor },
          },
          '& .MuiSelect-icon': {
            color: { xs: mobileTextColor, md: desktopTextColor },
          },
          '& .MuiPaper-root': {
            backgroundColor: theme.palette.background.paper,
          },
        }}
      >
        <MenuItem value="en" sx={{ color: mobileTextColor }}>{t('en')}</MenuItem> 
        <MenuItem value="ja" sx={{ color: mobileTextColor }}>{t('ja')}</MenuItem>
      </Select>
    </FormControl>
  );
};

export default LanguageSwitcher;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/lib/prisma.ts
TYPE: typescript
CONTENT:
```
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client';

// Declare a global variable to store the PrismaClient instance in development
// This prevents multiple instances of PrismaClient being created during hot-reloading
declare global {
  var prisma: PrismaClient | undefined;
}

let prisma: PrismaClient;

if (process.env.NODE_ENV === 'production') {
  prisma = new PrismaClient();
} else {
  // In development, use the global variable if it exists, otherwise create a new instance
  if (!global.prisma) {
    global.prisma = new PrismaClient();
  }
  prisma = global.prisma;
}

export default prisma;

```
--- FILE_END ---

--- FILE_START ---
PATH: src/lib/calculations.test.ts
TYPE: typescript
CONTENT:
```
import {
  calculateLunchMealSummary,
  calculateDinnerMealSummary,
  calculateDailyEarnings,
  calculateRangeSummary,
  calculateDailySummariesForRange,
  MealSummary,
  DailySummary,
} from './calculations';
import { Bill } from '@/types/Bill';
import { AppConfig } from '@/config/app';

describe('Calculation Functions', () => {
  // --- calculateLunchMealSummary ---
  describe('calculateLunchMealSummary', () => {
    it('should calculate lunch summary correctly with base income only', () => {
      const foodAmount = AppConfig.LUNCH_FOOD_BASE_INCOME;
      const drinkAmount = 1000;
      const result = calculateLunchMealSummary(foodAmount, drinkAmount);
      expect(result).toEqual<MealSummary>({
        rawFoodTotal: foodAmount,
        rawDrinkTotal: drinkAmount,
        foodEarnings: AppConfig.LUNCH_FOOD_BASE_INCOME,
        drinkEarnings: drinkAmount * AppConfig.LUNCH_DRINK_SHARE_PERCENT,
        phulkasEarnings: AppConfig.LUNCH_FOOD_BASE_INCOME + (drinkAmount * AppConfig.LUNCH_DRINK_SHARE_PERCENT),
      });
    });

    it('should calculate lunch summary correctly with overage', () => {
      const foodAmount = 10000;
      const drinkAmount = 2000;
      const overage = foodAmount - AppConfig.LUNCH_FOOD_BASE_INCOME;
      const expectedFoodEarnings = AppConfig.LUNCH_FOOD_BASE_INCOME + (overage * AppConfig.LUNCH_FOOD_OVERAGE_SHARE_PERCENT);
      const expectedDrinkEarnings = drinkAmount * AppConfig.LUNCH_DRINK_SHARE_PERCENT;

      const result = calculateLunchMealSummary(foodAmount, drinkAmount);
      expect(result).toEqual<MealSummary>({
        rawFoodTotal: foodAmount,
        rawDrinkTotal: drinkAmount,
        foodEarnings: expectedFoodEarnings,
        drinkEarnings: expectedDrinkEarnings,
        phulkasEarnings: expectedFoodEarnings + expectedDrinkEarnings,
      });
    });

    it('should handle foodAmount less than base income (still provides base income)', () => {
      const foodAmount = AppConfig.LUNCH_FOOD_BASE_INCOME - 1000; // e.g., 7000 if base is 8000
      const drinkAmount = 500;
      const result = calculateLunchMealSummary(foodAmount, drinkAmount);
      expect(result).toEqual<MealSummary>({
        rawFoodTotal: foodAmount,
        rawDrinkTotal: drinkAmount,
        foodEarnings: AppConfig.LUNCH_FOOD_BASE_INCOME, // Food earnings should be base income
        drinkEarnings: drinkAmount * AppConfig.LUNCH_DRINK_SHARE_PERCENT,
        phulkasEarnings: AppConfig.LUNCH_FOOD_BASE_INCOME + (drinkAmount * AppConfig.LUNCH_DRINK_SHARE_PERCENT),
      });
    });

    it('should handle zero food and drink amounts', () => {
      const result = calculateLunchMealSummary(0, 0);
      expect(result).toEqual<MealSummary>({
        rawFoodTotal: 0,
        rawDrinkTotal: 0,
        foodEarnings: AppConfig.LUNCH_FOOD_BASE_INCOME, // Food earnings should be base income
        drinkEarnings: 0,
        phulkasEarnings: AppConfig.LUNCH_FOOD_BASE_INCOME,
      });
    });
  });

  // --- calculateDinnerMealSummary ---
  describe('calculateDinnerMealSummary', () => {
    it('should calculate dinner summary correctly for our food (direct share)', () => {
      const foodAmount = 5000;
      const drinkAmount = 1000;
      const numberOfPeopleWorkingDinner = 2;
      const isOurFood = true;

      const expectedFoodEarnings = foodAmount * AppConfig.DINNER_FOOD_OUR_SHARE_PERCENT;
      const expectedDrinkEarnings = (drinkAmount * AppConfig.DINNER_DRINK_COMMON_POOL_PERCENT) / numberOfPeopleWorkingDinner;
      const expectedPhulkasEarnings = expectedFoodEarnings + expectedDrinkEarnings;

      const result = calculateDinnerMealSummary(foodAmount, drinkAmount, isOurFood, numberOfPeopleWorkingDinner);
      expect(result.rawFoodTotal).toBe(foodAmount);
      expect(result.rawDrinkTotal).toBe(drinkAmount);
      expect(result.foodEarnings).toBeCloseTo(expectedFoodEarnings);
      expect(result.drinkEarnings).toBeCloseTo(expectedDrinkEarnings); // Corrected expectation
      expect(result.phulkasEarnings).toBeCloseTo(expectedPhulkasEarnings);
      expect(result.isOurFood).toBe(isOurFood);
      expect(result.numberOfPeopleWorkingDinner).toBe(numberOfPeopleWorkingDinner);
    });

    it('should calculate dinner summary correctly for not our food (common pool for both)', () => {
      const foodAmount = 5000;
      const drinkAmount = 1000;
      const numberOfPeopleWorkingDinner = 2;
      const isOurFood = false;

      const expectedFoodEarnings = (foodAmount * AppConfig.DINNER_FOOD_COMMON_POOL_PERCENT) / numberOfPeopleWorkingDinner;
      const expectedDrinkEarnings = (drinkAmount * AppConfig.DINNER_DRINK_COMMON_POOL_PERCENT) / numberOfPeopleWorkingDinner;
      const expectedPhulkasEarnings = expectedFoodEarnings + expectedDrinkEarnings;

      const result = calculateDinnerMealSummary(foodAmount, drinkAmount, isOurFood, numberOfPeopleWorkingDinner);
      expect(result.rawFoodTotal).toBe(foodAmount);
      expect(result.rawDrinkTotal).toBe(drinkAmount);
      expect(result.foodEarnings).toBeCloseTo(expectedFoodEarnings);
      expect(result.drinkEarnings).toBeCloseTo(expectedDrinkEarnings);
      expect(result.phulkasEarnings).toBeCloseTo(expectedPhulkasEarnings);
      expect(result.isOurFood).toBe(isOurFood);
      expect(result.numberOfPeopleWorkingDinner).toBe(numberOfPeopleWorkingDinner);
    });

    it('should handle zero food and drink amounts', () => {
      const result = calculateDinnerMealSummary(0, 0, true, 1);
      expect(result).toEqual<MealSummary>({
        rawFoodTotal: 0,
        rawDrinkTotal: 0,
        foodEarnings: 0,
        drinkEarnings: 0,
        phulkasEarnings: 0,
        isOurFood: true,
        numberOfPeopleWorkingDinner: 1,
      });
    });

    it('should handle zero people working (effective workers should be 1)', () => {
      const foodAmount = 1000;
      const drinkAmount = 500;
      const isOurFood = false;
      const numberOfPeopleWorkingDinner = 0; // Test case for zero workers

      const expectedFoodEarnings = (foodAmount * AppConfig.DINNER_FOOD_COMMON_POOL_PERCENT) / 1;
      const expectedDrinkEarnings = (drinkAmount * AppConfig.DINNER_DRINK_COMMON_POOL_PERCENT) / 1;
      const expectedPhulkasEarnings = expectedFoodEarnings + expectedDrinkEarnings;

      const result = calculateDinnerMealSummary(foodAmount, drinkAmount, isOurFood, numberOfPeopleWorkingDinner);
      expect(result.rawFoodTotal).toBe(foodAmount);
      expect(result.rawDrinkTotal).toBe(drinkAmount);
      expect(result.foodEarnings).toBeCloseTo(expectedFoodEarnings);
      expect(result.drinkEarnings).toBeCloseTo(expectedDrinkEarnings);
      expect(result.phulkasEarnings).toBeCloseTo(expectedPhulkasEarnings);
      expect(result.isOurFood).toBe(isOurFood);
      expect(result.numberOfPeopleWorkingDinner).toBe(numberOfPeopleWorkingDinner);
    });
  });

  // --- calculateDailyEarnings ---
  describe('calculateDailyEarnings', () => {
    it('should calculate daily earnings correctly for a mix of lunch and dinner bills', () => {
      const bills: Bill[] = [
        {
          id: '1',
          date: '2024-07-20',
          foodAmount: 10000, // Lunch overage
          drinkAmount: 2000, // Lunch drinks
          mealType: 'lunch',
          isOurFood: true,
          numberOfPeopleWorkingDinner: 1,
          comments: '',
        },
        {
          id: '2',
          date: '2024-07-20',
          foodAmount: 5000, // Dinner
          drinkAmount: 1000, // Dinner
          mealType: 'dinner',
          isOurFood: true, // Our food dinner
          numberOfPeopleWorkingDinner: 2,
          comments: '',
        },
      ];

      const expectedLunchSummary = calculateLunchMealSummary(bills[0].foodAmount, bills[0].drinkAmount);
      const expectedDinnerSummary = calculateDinnerMealSummary(
        bills[1].foodAmount,
        bills[1].drinkAmount,
        bills[1].isOurFood,
        bills[1].numberOfPeopleWorkingDinner!
      );

      const result = calculateDailyEarnings(bills);

      expect(result.lunch).toEqual(expectedLunchSummary);
      expect(result.dinner).toEqual(expectedDinnerSummary);
      expect(result.dayTotalEarnings).toBeCloseTo(expectedLunchSummary.phulkasEarnings + expectedDinnerSummary.phulkasEarnings);
    });

    it('should handle multiple lunch bills for the same day', () => {
      const bills: Bill[] = [
        {
          id: '1',
          date: '2024-07-20',
          foodAmount: 5000,
          drinkAmount: 500,
          mealType: 'lunch',
          isOurFood: true,
          numberOfPeopleWorkingDinner: 1,
          comments: '',
        },
        {
          id: '2',
          date: '2024-07-20',
          foodAmount: 4000,
          drinkAmount: 300,
          mealType: 'lunch',
          isOurFood: true,
          numberOfPeopleWorkingDinner: 1,
          comments: '',
        },
      ];
      const totalFood = 5000 + 4000;
      const totalDrinks = 500 + 300;
      const expectedLunchSummary = calculateLunchMealSummary(totalFood, totalDrinks);
      const result = calculateDailyEarnings(bills);
      expect(result.lunch).toEqual(expectedLunchSummary);
      expect(result.dinner.phulkasEarnings).toBe(0); // No dinner bills
      expect(result.dayTotalEarnings).toBeCloseTo(expectedLunchSummary.phulkasEarnings);
    });

    it('should handle multiple dinner bills for the same day (aggregating raw amounts, using last flags)', () => {
      const bills: Bill[] = [
        {
          id: '1',
          date: '2024-07-20',
          foodAmount: 3000,
          drinkAmount: 500,
          mealType: 'dinner',
          isOurFood: false, // First dinner bill: not our food
          numberOfPeopleWorkingDinner: 1,
          comments: '',
        },
        {
          id: '2',
          date: '2024-07-20',
          foodAmount: 4000,
          drinkAmount: 800,
          mealType: 'dinner',
          isOurFood: true, // Second dinner bill: our food (this one's flags should be used)
          numberOfPeopleWorkingDinner: 3,
          comments: '',
        },
      ];
      const totalFood = 3000 + 4000;
      const totalDrinks = 500 + 800;
      const expectedDinnerSummary = calculateDinnerMealSummary(
        totalFood,
        totalDrinks,
        bills[1].isOurFood, // Use flags from the last bill
        bills[1].numberOfPeopleWorkingDinner!
      );
      const result = calculateDailyEarnings(bills);
      expect(result.dinner).toEqual(expectedDinnerSummary);
      expect(result.lunch.phulkasEarnings).toBe(0); // No lunch bills
      expect(result.dayTotalEarnings).toBeCloseTo(expectedDinnerSummary.phulkasEarnings);
    });

    it('should handle no bills', () => {
      const bills: Bill[] = [];
      const result = calculateDailyEarnings(bills);
      expect(result.lunch.phulkasEarnings).toBe(0);
      expect(result.dinner.phulkasEarnings).toBe(0);
      expect(result.dayTotalEarnings).toBe(0);
    });
  });

  // --- calculateDailySummariesForRange ---
  describe('calculateDailySummariesForRange', () => {
    it('should group bills by date and calculate daily summaries for each', () => {
      const bills: Bill[] = [
        { id: '1', date: '2024-07-20', foodAmount: 10000, drinkAmount: 2000, mealType: 'lunch', isOurFood: true, numberOfPeopleWorkingDinner: 1, comments: '' },
        { id: '2', date: '2024-07-20', foodAmount: 5000, drinkAmount: 1000, mealType: 'dinner', isOurFood: true, numberOfPeopleWorkingDinner: 2, comments: '' },
        { id: '3', date: '2024-07-21', foodAmount: 8000, drinkAmount: 1500, mealType: 'lunch', isOurFood: true, numberOfPeopleWorkingDinner: 1, comments: '' },
        { id: '4', date: '2024-07-21', foodAmount: 4000, drinkAmount: 800, mealType: 'dinner', isOurFood: false, numberOfPeopleWorkingDinner: 3, comments: '' },
        { id: '5', date: '2024-07-19', foodAmount: 2000, drinkAmount: 300, mealType: 'lunch', isOurFood: true, numberOfPeopleWorkingDinner: 1, comments: '' },
      ];

      const result = calculateDailySummariesForRange(bills);

      // Expect 3 entries for 3 distinct dates
      expect(result.length).toBe(3);

      // Check sorting (latest date first)
      expect(result[0].date).toBe('2024-07-21');
      expect(result[1].date).toBe('2024-07-20');
      expect(result[2].date).toBe('2024-07-19');

      // Verify calculations for a specific day (e.g., 2024-07-20)
      const day1Summary = result.find(entry => entry.date === '2024-07-20')?.summary;
      expect(day1Summary).toBeDefined();
      if (day1Summary) {
        const billsForDay1 = bills.filter(b => b.date === '2024-07-20');
        const expectedDay1Summary = calculateDailyEarnings(billsForDay1);
        expect(day1Summary).toEqual(expectedDay1Summary);
      }

      // Verify calculations for another day (e.g., 2024-07-21)
      const day2Summary = result.find(entry => entry.date === '2024-07-21')?.summary;
      expect(day2Summary).toBeDefined();
      if (day2Summary) {
        const billsForDay2 = bills.filter(b => b.date === '2024-07-21');
        const expectedDay2Summary = calculateDailyEarnings(billsForDay2);
        expect(day2Summary).toEqual(expectedDay2Summary);
      }

      // Verify calculations for 2024-07-19
      const day3Summary = result.find(entry => entry.date === '2024-07-19')?.summary;
      expect(day3Summary).toBeDefined();
      if (day3Summary) {
        const billsForDay3 = bills.filter(b => b.date === '2024-07-19');
        const expectedDay3Summary = calculateDailyEarnings(billsForDay3);
        expect(day3Summary).toEqual(expectedDay3Summary);
      }
    });

    it('should return an empty array if no bills are provided', () => {
      const bills: Bill[] = [];
      const result = calculateDailySummariesForRange(bills);
      expect(result).toEqual([]);
    });

    it('should handle bills with invalid dates gracefully (skipping them)', () => {
        const bills: Bill[] = [
            { id: '1', date: '2024-07-20', foodAmount: 1000, drinkAmount: 100, mealType: 'lunch', isOurFood: true, numberOfPeopleWorkingDinner: 1, comments: '' },
            { id: 'invalid', date: 'invalid-date', foodAmount: 500, drinkAmount: 50, mealType: 'dinner', isOurFood: false, numberOfPeopleWorkingDinner: 1, comments: '' },
        ];
        const result = calculateDailySummariesForRange(bills);
        expect(result.length).toBe(1);
        expect(result[0].date).toBe('2024-07-20');
    });
  });

  // --- calculateRangeSummary ---
  describe('calculateRangeSummary', () => {
    it('should correctly aggregate summaries for a given range of bills', () => {
      const bills: Bill[] = [
        // Day 1: 2024-07-20
        { id: '1', date: '2024-07-20', foodAmount: 10000, drinkAmount: 2000, mealType: 'lunch', isOurFood: true, numberOfPeopleWorkingDinner: 1, comments: '' },
        { id: '2', date: '2024-07-20', foodAmount: 5000, drinkAmount: 1000, mealType: 'dinner', isOurFood: true, numberOfPeopleWorkingDinner: 2, comments: '' },
        // Day 2: 2024-07-21
        { id: '3', date: '2024-07-21', foodAmount: 8000, drinkAmount: 1500, mealType: 'lunch', isOurFood: true, numberOfPeopleWorkingDinner: 1, comments: '' },
        { id: '4', date: '2024-07-21', foodAmount: 4000, drinkAmount: 800, mealType: 'dinner', isOurFood: false, numberOfPeopleWorkingDinner: 3, comments: '' },
      ];

      const dailySummaries = calculateDailySummariesForRange(bills);
      const expectedTotalLunchPhulkasEarnings = dailySummaries.reduce((sum, entry) => sum + entry.summary.lunch.phulkasEarnings, 0);
      const expectedTotalDinnerPhulkasEarnings = dailySummaries.reduce((sum, entry) => sum + entry.summary.dinner.phulkasEarnings, 0);
      const expectedDayTotalEarnings = dailySummaries.reduce((sum, entry) => sum + entry.summary.dayTotalEarnings, 0);

      const result = calculateRangeSummary(bills);

      const expectedRawFoodTotal = dailySummaries.reduce((sum, entry) => sum + entry.summary.lunch.rawFoodTotal + entry.summary.dinner.rawFoodTotal, 0);
      const expectedRawDrinkTotal = dailySummaries.reduce((sum, entry) => sum + entry.summary.lunch.rawDrinkTotal + entry.summary.dinner.rawDrinkTotal, 0);

      expect(result.lunch.rawFoodTotal).toBe(expectedRawFoodTotal);
      expect(result.lunch.rawDrinkTotal).toBe(expectedRawDrinkTotal);
      expect(result.lunch.phulkasEarnings).toBeCloseTo(expectedTotalLunchPhulkasEarnings);

      expect(result.dinner.rawFoodTotal).toBe(0); // Dinner raw totals are 0 in calculateRangeSummary's MealSummary for dinner
      expect(result.dinner.rawDrinkTotal).toBe(0); // Dinner raw totals are 0 in calculateRangeSummary's MealSummary for dinner
      expect(result.dinner.phulkasEarnings).toBeCloseTo(expectedTotalDinnerPhulkasEarnings);

      expect(result.dayTotalEarnings).toBeCloseTo(expectedDayTotalEarnings);
    });

    it('should return a default summary if no bills are provided', () => {
      const bills: Bill[] = [];
      const result = calculateRangeSummary(bills);
      expect(result).toEqual({
        lunch: {
          rawFoodTotal: 0,
          rawDrinkTotal: 0,
          foodEarnings: 0,
          drinkEarnings: 0,
          phulkasEarnings: 0
        },
        dinner: {
          rawFoodTotal: 0,
          rawDrinkTotal: 0,
          foodEarnings: 0,
          drinkEarnings: 0,
          phulkasEarnings: 0
        },
        dayTotalEarnings: 0
      });
    });
  });
});

```
--- FILE_END ---

--- FILE_START ---
PATH: src/lib/calculations.ts
TYPE: typescript
CONTENT:
```
import { Bill } from '@/types/bill';
import { AppConfig } from '@/config/app';
import { format, isValid, parseISO } from 'date-fns';

export interface MealSummary {
  rawFoodTotal: number;
  rawDrinkTotal: number;
  foodEarnings: number;
  drinkEarnings: number;
  phulkasEarnings: number;
  isOurFood?: boolean;
  numberOfPeopleWorkingDinner?: number;
}

export interface DailySummary {
  lunch: MealSummary;
  dinner: MealSummary;
  dayTotalEarnings: number;
}

const getDefaultMealSummary = (): MealSummary => ({
  rawFoodTotal: 0,
  rawDrinkTotal: 0,
  foodEarnings: 0,
  drinkEarnings: 0,
  phulkasEarnings: 0,
});

const getDefaultDailySummary = (): DailySummary => ({
  lunch: getDefaultMealSummary(),
  dinner: getDefaultMealSummary(),
  dayTotalEarnings: 0,
});

export const calculateLunchMealSummary = (foodAmount: number, drinkAmount: number): MealSummary => {
  const foodOverage = Math.max(0, foodAmount - AppConfig.LUNCH_FOOD_BASE_INCOME);
  const foodEarnings = AppConfig.LUNCH_FOOD_BASE_INCOME + (foodOverage * AppConfig.LUNCH_FOOD_OVERAGE_SHARE_PERCENT);
  const drinkEarnings = drinkAmount * AppConfig.LUNCH_DRINK_SHARE_PERCENT;
  const phulkasEarnings = foodEarnings + drinkEarnings;
  return {
    rawFoodTotal: foodAmount,
    rawDrinkTotal: drinkAmount,
    foodEarnings: foodEarnings,
    drinkEarnings: drinkEarnings,
    phulkasEarnings: phulkasEarnings,
  };
};

export const calculateDinnerMealSummary = (foodAmount: number, drinkAmount: number, isOurFood: boolean, numberOfPeopleWorkingDinner: number): MealSummary => {
  const effectiveWorkers = Math.max(1, numberOfPeopleWorkingDinner);
  
  let foodEarnings = 0;
  let drinkEarnings = 0;

  if (isOurFood) {
    // If it's 'our food', we get a direct share of the food amount
    foodEarnings = foodAmount * AppConfig.DINNER_FOOD_OUR_SHARE_PERCENT;
    // The drink amount still goes to a common pool and is shared
    drinkEarnings = (drinkAmount * AppConfig.DINNER_DRINK_COMMON_POOL_PERCENT) / effectiveWorkers;
  } else {
    // If it's NOT 'our food', both food and drink contribute to the common pool
    // and our earnings come from our share of that total common pool.
    // The `foodEarnings` and `drinkEarnings` here represent our share from their respective common pools.
    foodEarnings = (foodAmount * AppConfig.DINNER_FOOD_COMMON_POOL_PERCENT) / effectiveWorkers;
    drinkEarnings = (drinkAmount * AppConfig.DINNER_DRINK_COMMON_POOL_PERCENT) / effectiveWorkers;
  }

  const phulkasEarnings = foodEarnings + drinkEarnings;

  return {
    rawFoodTotal: foodAmount,
    rawDrinkTotal: drinkAmount,
    foodEarnings: foodEarnings,
    drinkEarnings: drinkEarnings,
    phulkasEarnings: phulkasEarnings,
    isOurFood: isOurFood,
    numberOfPeopleWorkingDinner: numberOfPeopleWorkingDinner,
  };
};

export const calculateDailyEarnings = (bills: Bill[]): DailySummary => {
  const dailySummary: DailySummary = getDefaultDailySummary();

  let totalLunchFoodAmount = 0;
  let totalLunchDrinkAmount = 0;

  let tempDinnerFoodTotal = 0;
  let tempDinnerDrinkTotal = 0;
  let tempDinnerIsOurFood: boolean = true; // Default or last encountered
  let tempDinnerNumWorkers: number = 1; // Default or last encountered

  bills.forEach(bill => {
    if (bill.mealType === 'lunch') {
      totalLunchFoodAmount += bill.foodAmount;
      totalLunchDrinkAmount += bill.drinkAmount;
    } else if (bill.mealType === 'dinner') {
      tempDinnerFoodTotal += bill.foodAmount;
      tempDinnerDrinkTotal += bill.drinkAmount;
      tempDinnerIsOurFood = bill.isOurFood ?? true;
      tempDinnerNumWorkers = bill.numberOfPeopleWorkingDinner ?? 1;
    }
  });

  if (totalLunchFoodAmount > 0 || totalLunchDrinkAmount > 0) {
    const aggregatedLunchSummary = calculateLunchMealSummary(totalLunchFoodAmount, totalLunchDrinkAmount);
    dailySummary.lunch = aggregatedLunchSummary;
  }

  if (tempDinnerFoodTotal > 0 || tempDinnerDrinkTotal > 0) {
    const aggregatedDinnerSummary = calculateDinnerMealSummary(
      tempDinnerFoodTotal,
      tempDinnerDrinkTotal,
      tempDinnerIsOurFood,
      tempDinnerNumWorkers
    );
    dailySummary.dinner = aggregatedDinnerSummary;
  }

  dailySummary.dayTotalEarnings = dailySummary.lunch.phulkasEarnings + dailySummary.dinner.phulkasEarnings;
  return dailySummary;
};

export const calculateRangeSummary = (bills: Bill[]): DailySummary => {
  let totalRawFood = 0;
  let totalRawDrink = 0;
  let totalLunchPhulkasEarnings = 0;
  let totalDinnerPhulkasEarnings = 0;
  let totalOverallPhulkasEarnings = 0;

  const dailySummaries = calculateDailySummariesForRange(bills);

  dailySummaries.forEach(dailyEntry => {
    totalRawFood += dailyEntry.summary.lunch.rawFoodTotal + dailyEntry.summary.dinner.rawFoodTotal;
    totalRawDrink += dailyEntry.summary.lunch.rawDrinkTotal + dailyEntry.summary.dinner.rawDrinkTotal;
    
    totalLunchPhulkasEarnings += dailyEntry.summary.lunch.phulkasEarnings;
    totalDinnerPhulkasEarnings += dailyEntry.summary.dinner.phulkasEarnings;
    
    totalOverallPhulkasEarnings += dailyEntry.summary.dayTotalEarnings;
  });

  const summaryForRange: DailySummary = {
    lunch: {
      rawFoodTotal: totalRawFood,
      rawDrinkTotal: totalRawDrink,
      foodEarnings: 0,
      drinkEarnings: 0,
      phulkasEarnings: totalLunchPhulkasEarnings
    },
    dinner: {
      rawFoodTotal: 0,
      rawDrinkTotal: 0,
      foodEarnings: 0,
      drinkEarnings: 0,
      phulkasEarnings: totalDinnerPhulkasEarnings
    },
    dayTotalEarnings: totalOverallPhulkasEarnings
  };

  return summaryForRange;
};

export const calculateDailySummariesForRange = (bills: Bill[]): { date: string; summary: DailySummary }[] => {
  const dailyBillsMap: { [key: string]: Bill[] } = {};

  bills.forEach(bill => {
    const parsedDate = parseISO(bill.date);
    if (isValid(parsedDate)) {
      const billDate = format(parsedDate, 'yyyy-MM-dd');
      if (!dailyBillsMap[billDate]) {
        dailyBillsMap[billDate] = [];
      }
      dailyBillsMap[billDate].push(bill);
    } else {
      console.warn(`Skipping bill with invalid date: ${bill.date}`);
    }
  });

  return Object.keys(dailyBillsMap)
    .sort((a, b) => b.localeCompare(a))
    .map(date => {
      const billsForThisDay = dailyBillsMap[date];
      const dailySummary = calculateDailyEarnings(billsForThisDay);
      return { date, summary: dailySummary };
    });
};

```
--- FILE_END ---

--- FILE_START ---
PATH: src/lib/db.ts
TYPE: typescript
CONTENT:
```
// src/lib/db.ts
import { PrismaClient, MealType } from '@prisma/client'; // Import MealType enum from Prisma
import { BillFormData } from '@/components/BillForm'; // Assuming BillFormData is defined here or adjust path

// Instantiate PrismaClient
const prisma = new PrismaClient();

// Define the type for Bill data retrieved from Prisma
// This should match your Prisma schema Bill model
export interface Bill {
  id: number;
  date: Date; // Prisma typically returns Date objects for datetime fields
  mealType: MealType; // Use the imported MealType enum type
  foodAmount: number;
  drinkAmount: number;
  isOurFood: boolean | null; // Assuming nullable boolean in DB for dinner-specific field
  numberOfPeopleWorkingDinner: number | null; // Assuming nullable int in DB for dinner-specific field
  createdAt: Date;
  updatedAt: Date;
}

// Function to create a new bill
export const createBill = async (data: BillFormData): Promise<Bill> => {
  try {
    const newBill = await prisma.bill.create({
      data: {
        date: new Date(data.date), // Ensure date is a Date object
        // Convert lowercase string to uppercase MealType enum value
        mealType: data.mealType.toUpperCase() as MealType,
        foodAmount: data.foodAmount,
        drinkAmount: data.drinkAmount,
        // Map dinner-specific fields only if mealType is 'dinner'
        isOurFood: data.mealType === 'dinner' ? data.isOurFood ?? null : null,
        numberOfPeopleWorkingDinner: data.mealType === 'dinner' ? data.numberOfPeopleWorkingDinner ?? null : null,
      },
    });
    return newBill as Bill;
  } catch (error) {
    throw new Error("Failed to create bill.");
  }
};

// Function to get all bills within a date range
export const getBillsByDateRange = async (fromDate: string, toDate: string): Promise<Bill[]> => {
  try {
    // Parse date strings to Date objects for comparison
    const startDate = new Date(fromDate);
    const endDate = new Date(toDate);

    const bills = await prisma.bill.findMany({
      where: {
        date: {
          gte: startDate, // Greater than or equal to start date
          lte: endDate,   // Less than or equal to end date
        },
      },
      orderBy: {
        date: 'desc', // Order by date descending
      },
    });
    return bills as Bill[];
  } catch (error) {
    throw new Error("Failed to fetch bills.");
  }
};

// Function to get a single bill by ID
export const getBillById = async (id: number): Promise<Bill | null> => {
  try {
    const bill = await prisma.bill.findUnique({
      where: {
        id: id,
      },
    });
    return bill as Bill | null;
  } catch (error) {
    throw new Error(`Failed to fetch bill with ID ${id}.`);
  }
};

// Function to update an existing bill
export const updateBill = async (id: number, data: BillFormData): Promise<Bill> => {
  try {
    const updatedBill = await prisma.bill.update({
      where: {
        id: id,
      },
      data: {
        date: new Date(data.date), // Ensure date is a Date object
        // Convert lowercase string to uppercase MealType enum value
        mealType: data.mealType.toUpperCase() as MealType,
        foodAmount: data.foodAmount,
        drinkAmount: data.drinkAmount,
        // Map dinner-specific fields only if mealType is 'dinner'
        isOurFood: data.mealType === 'dinner' ? data.isOurFood ?? null : null,
        numberOfPeopleWorkingDinner: data.mealType === 'dinner' ? data.numberOfPeopleWorkingDinner ?? null : null,
      },
    });
    return updatedBill as Bill;
  } catch (error) {
    throw new Error(`Failed to update bill with ID ${id}.`);
  }
};

// Function to delete a bill by ID
export const deleteBill = async (id: number): Promise<Bill> => {
  try {
    const deletedBill = await prisma.bill.delete({
      where: {
        id: id,
      },
    });
    return deletedBill as Bill;
  } catch (error) {
    throw new Error(`Failed to delete bill with ID ${id}.`);
  }
};

```
--- FILE_END ---

--- FILE_START ---
PATH: src/i18n/navigation.ts
TYPE: typescript
CONTENT:
```
import {createNavigation} from 'next-intl/navigation';
import {routing} from './routing';
 
// Lightweight wrappers around Next.js' navigation
// APIs that consider the routing configuration
export const {Link, redirect, usePathname, useRouter, getPathname} =
  createNavigation(routing);
```
--- FILE_END ---


Consolidation complete. You can copy the above output.
